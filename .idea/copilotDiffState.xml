<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/core/src/com/mygdx/game/MainGame.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/src/com/mygdx/game/MainGame.java" />
              <option name="updatedContent" value="package com.mygdx.game;&#10;&#10;import com.badlogic.gdx.Game;&#10;&#10;public class MainGame extends Game {&#10;    @Override&#10;    public void create() {&#10;        setScreen(new PantallaMenu(this));&#10;    }&#10;    // ...resto del código...&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/src/com/mygdx/game/PantallaMenu.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/src/com/mygdx/game/PantallaMenu.java" />
              <option name="originalContent" value="package com.mygdx.game;&#10;&#10;import com.badlogic.gdx.Gdx;&#10;import com.badlogic.gdx.Screen;&#10;import com.badlogic.gdx.graphics.GL20;&#10;import com.badlogic.gdx.scenes.scene2d.Stage;&#10;import com.badlogic.gdx.scenes.scene2d.ui.Skin;&#10;import com.badlogic.gdx.scenes.scene2d.ui.TextButton;&#10;import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;&#10;import com.badlogic.gdx.scenes.scene2d.InputEvent;&#10;import com.badlogic.gdx.utils.viewport.ScreenViewport;&#10;&#10;public class PantallaMenu implements Screen {&#10;    private final MainGame game;&#10;    private Stage stage;&#10;    private Skin skin;&#10;&#10;    public PantallaMenu(MainGame game) {&#10;        this.game = game;&#10;    }&#10;&#10;    @Override&#10;    public void show() {&#10;        stage = new Stage(new ScreenViewport());&#10;        Gdx.input.setInputProcessor(stage);&#10;&#10;        skin = new Skin(Gdx.files.internal(&quot;uiskin.json&quot;)); // Asegúrate de tener este skin&#10;&#10;        TextButton jugarBtn = new TextButton(&quot;Jugar&quot;, skin);&#10;        jugarBtn.setSize(200, 60);&#10;        jugarBtn.setPosition(&#10;            Gdx.graphics.getWidth() / 2f - jugarBtn.getWidth() / 2,&#10;            Gdx.graphics.getHeight() / 2f - jugarBtn.getHeight() / 2&#10;        );&#10;        jugarBtn.addListener(new ClickListener() {&#10;            @Override&#10;            public void clicked(InputEvent event, float x, float y) {&#10;                game.setScreen(new PantallaPartida(game));&#10;            }&#10;        });&#10;&#10;        stage.addActor(jugarBtn);&#10;    }&#10;&#10;    @Override&#10;    public void render(float delta) {&#10;        Gdx.gl.glClearColor(0, 0, 0, 1);&#10;        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);&#10;        stage.act(delta);&#10;        stage.draw();&#10;    }&#10;&#10;    @Override&#10;    public void resize(int width, int height) {&#10;        stage.getViewport().update(width, height, true);&#10;    }&#10;&#10;    @Override&#10;    public void pause() {}&#10;&#10;    @Override&#10;    public void resume() {}&#10;&#10;    @Override&#10;    public void hide() {&#10;        stage.dispose();&#10;        skin.dispose();&#10;    }&#10;&#10;    @Override&#10;    public void dispose() {&#10;        stage.dispose();&#10;        skin.dispose();&#10;&#10;" />
              <option name="updatedContent" value="package com.mygdx.game;&#10;&#10;import com.badlogic.gdx.Gdx;&#10;import com.badlogic.gdx.Screen;&#10;import com.badlogic.gdx.graphics.GL20;&#10;import com.badlogic.gdx.scenes.scene2d.Stage;&#10;import com.badlogic.gdx.scenes.scene2d.ui.Skin;&#10;import com.badlogic.gdx.scenes.scene2d.ui.TextButton;&#10;import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;&#10;import com.badlogic.gdx.scenes.scene2d.InputEvent;&#10;import com.badlogic.gdx.utils.viewport.ScreenViewport;&#10;&#10;public class PantallaMenu implements Screen {&#10;    private final MainGame game;&#10;    private Stage stage;&#10;    private Skin skin;&#10;&#10;    public PantallaMenu(MainGame game) {&#10;        this.game = game;&#10;    }&#10;&#10;    @Override&#10;    public void show() {&#10;        stage = new Stage(new ScreenViewport());&#10;        Gdx.input.setInputProcessor(stage);&#10;&#10;        skin = new Skin(Gdx.files.internal(&quot;uiskin.json&quot;)); // Asegúrate de tener este skin&#10;&#10;        TextButton jugarBtn = new TextButton(&quot;Jugar&quot;, skin);&#10;        jugarBtn.setSize(200, 60);&#10;        jugarBtn.setPosition(&#10;            Gdx.graphics.getWidth() / 2f - jugarBtn.getWidth() / 2,&#10;            Gdx.graphics.getHeight() / 2f - jugarBtn.getHeight() / 2&#10;        );&#10;        jugarBtn.addListener(new ClickListener() {&#10;            @Override&#10;            public void clicked(InputEvent event, float x, float y) {&#10;                game.setScreen(new PantallaPartida(game));&#10;            }&#10;        });&#10;&#10;        stage.addActor(jugarBtn);&#10;    }&#10;&#10;    @Override&#10;    public void render(float delta) {&#10;        Gdx.gl.glClearColor(0, 0, 0, 1);&#10;        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);&#10;        stage.act(delta);&#10;        stage.draw();&#10;    }&#10;&#10;    @Override&#10;    public void resize(int width, int height) {&#10;        stage.getViewport().update(width, height, true);&#10;    }&#10;&#10;    @Override&#10;    public void pause() {}&#10;&#10;    @Override&#10;    public void resume() {}&#10;&#10;    @Override&#10;    public void hide() {&#10;        stage.dispose();&#10;        skin.dispose();&#10;    }&#10;&#10;    @Override&#10;    public void dispose() {&#10;        stage.dispose();&#10;        skin.dispose();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/src/com/mygdx/game/PantallaPartida.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/src/com/mygdx/game/PantallaPartida.java" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.mygdx.game;&#10;&#10;import com.badlogic.gdx.Screen;&#10;import com.badlogic.gdx.Gdx;&#10;import com.badlogic.gdx.graphics.GL20;&#10;&#10;public class PantallaPartida implements Screen {&#10;    private final MainGame game;&#10;&#10;    public PantallaPartida(MainGame game) {&#10;        this.game = game;&#10;        // ...aquí puedes inicializar recursos de la partida...&#10;    }&#10;&#10;    @Override&#10;    public void show() {&#10;        // ...código de inicialización de la pantalla de partida...&#10;    }&#10;&#10;    @Override&#10;    public void render(float delta) {&#10;        Gdx.gl.glClearColor(0.1f, 0.1f, 0.1f, 1);&#10;        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);&#10;        // ...lógica y renderizado de la partida...&#10;    }&#10;&#10;    @Override&#10;    public void resize(int width, int height) {&#10;        // ...si necesitas ajustar la vista...&#10;    }&#10;&#10;    @Override&#10;    public void pause() {}&#10;&#10;    @Override&#10;    public void resume() {}&#10;&#10;    @Override&#10;    public void hide() {&#10;        // ...libera recursos si es necesario...&#10;    }&#10;&#10;    @Override&#10;    public void dispose() {&#10;        // ...libera recursos de la partida...&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/src/main/java/com.Envit.Juego/pantallas/PantallaPartida.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/src/main/java/com.Envit.Juego/pantallas/PantallaPartida.java" />
              <option name="originalContent" value="package com.Envit.Juego.pantallas;&#10;&#10;import com.Envit.Juego.Principal;&#10;import com.badlogic.gdx.Gdx;&#10;import com.badlogic.gdx.Screen;&#10;import com.badlogic.gdx.Input;&#10;import com.badlogic.gdx.graphics.Color;&#10;import com.badlogic.gdx.graphics.GL20;&#10;import com.badlogic.gdx.graphics.Texture;&#10;import com.badlogic.gdx.graphics.g2d.SpriteBatch;&#10;import com.badlogic.gdx.graphics.g2d.TextureRegion;&#10;import com.badlogic.gdx.math.MathUtils;&#10;import com.badlogic.gdx.utils.viewport.FitViewport;&#10;import com.badlogic.gdx.utils.viewport.Viewport;&#10;import com.badlogic.gdx.graphics.glutils.ShapeRenderer;&#10;import com.badlogic.gdx.math.Vector2;&#10;import com.badlogic.gdx.audio.Sound;&#10;import com.badlogic.gdx.math.Rectangle;&#10;&#10;public class PantallaPartida implements Screen {&#10;    private final Principal game;&#10;    private SpriteBatch batch;&#10;    private Texture barajaTexture;&#10;    private Texture fondoPartida;&#10;    private TextureRegion[][] cartas; // [fila][columna]&#10;    private int[][] cartasMostradas; // [3][2] -&gt; fila, columna&#10;    private Partida partida;&#10;    // Viewport para mantener relación de aspecto&#10;    private static final float VIRTUAL_WIDTH = 1000;&#10;    private static final float VIRTUAL_HEIGHT = 625;&#10;    private Viewport viewport;&#10;    private ShapeRenderer shapeRenderer;&#10;&#10;    // Gestión de estados&#10;    private enum EstadoJuego { JUGANDO, PAUSADO, FINALIZADO }&#10;    private EstadoJuego estado = EstadoJuego.JUGANDO;&#10;&#10;    // Ahora 6 cartas&#10;    private static final int NUM_CARTAS = 6;&#10;    private TextureRegion[] cartasRecortadas = new TextureRegion[NUM_CARTAS];&#10;    // Posiciones y arrastre&#10;    private Vector2[] cartaPos = new Vector2[NUM_CARTAS];&#10;    private boolean[] cartaArrastrando = new boolean[NUM_CARTAS];&#10;    private Vector2 arrastreOffset = new Vector2();&#10;    private int cartaSeleccionada = -1;&#10;&#10;    // Sonido al clickear carta&#10;    private Sound cartaClickSound;&#10;&#10;    // Posiciones objetivo para animación&#10;    private Vector2[] cartaPosObjetivo = new Vector2[NUM_CARTAS];&#10;&#10;    // Físicas para cartas&#10;    private Vector2[] cartaVel = new Vector2[NUM_CARTAS];&#10;    private Vector2[] cartaAcel = new Vector2[NUM_CARTAS];&#10;    private static final float CARTA_REPELENCIA = 42000f; // fuerza de repulsión entre cartas&#10;    private static final float CARTA_DISTANCIA_MIN = 100f; // distancia mínima antes de repeler&#10;&#10;    // Marco de carta&#10;    private Texture marcoCartaTexture;&#10;&#10;    // Casilla para jugar cartas&#10;    private Rectangle casillaCartas;&#10;&#10;    // Estado de cartas jugadas&#10;    private boolean[] cartaJugada = new boolean[NUM_CARTAS];&#10;&#10;    // Textura para la casilla&#10;    private Texture casillaTexture;&#10;&#10;    public PantallaPartida(Principal game) {&#10;&#10;        this.game = game;&#10;        this.partida = new Partida();&#10;&#10;&#10;    }&#10;&#10;    @Override&#10;    public void show() {&#10;        batch = new SpriteBatch();&#10;        shapeRenderer = new ShapeRenderer();&#10;        fondoPartida= new Texture(Gdx.files.internal(&quot;fondos/fondoPartida.png&quot;));&#10;        barajaTexture = new Texture(Gdx.files.internal(&quot;sprites/baraja2.png&quot;));&#10;        viewport = new FitViewport(VIRTUAL_WIDTH, VIRTUAL_HEIGHT);&#10;        recortarSeisCartas();&#10;        inicializarPosicionesCartas();&#10;        cartaClickSound = Gdx.audio.newSound(Gdx.files.internal(&quot;sounds/carta.wav&quot;));&#10;        marcoCartaTexture = new Texture(Gdx.files.internal(&quot;sprites/marcoCARTA.png&quot;));&#10;        casillaTexture = new Texture(Gdx.files.internal(&quot;sprites/casilla.png&quot;));&#10;        // Casilla centrada en el medio&#10;        float casillaW = 120, casillaH = 170;&#10;        casillaCartas = new Rectangle(&#10;            VIRTUAL_WIDTH/2f - casillaW/2,&#10;            VIRTUAL_HEIGHT/2f - casillaH/2,&#10;            casillaW,&#10;            casillaH&#10;        );&#10;        for (int i = 0; i &lt; NUM_CARTAS; i++) cartaJugada[i] = false;&#10;    }&#10;&#10;    // Recorta 6 cartas únicas&#10;    private void recortarSeisCartas() {&#10;        int cartaW = barajaTexture.getWidth() / 11;&#10;        int cartaH = barajaTexture.getHeight() / 4;&#10;        boolean[][] usadas = new boolean[4][11];&#10;        for (int i = 0; i &lt; NUM_CARTAS; i++) {&#10;            TextureRegion region = null;&#10;            int fila, col;&#10;            do {&#10;                fila = MathUtils.random(0, 3);&#10;                col = MathUtils.random(0, 10);&#10;            } while (usadas[fila][col]);&#10;            usadas[fila][col] = true;&#10;            region = new TextureRegion(barajaTexture, col * cartaW, fila * cartaH, cartaW, cartaH);&#10;            cartasRecortadas[i] = region;&#10;        }&#10;    }&#10;&#10;    // 3 cartas abajo, 3 arriba&#10;    private void inicializarPosicionesCartas() {&#10;        int cartaW = 100, cartaH = 150, espacio = 20;&#10;        int totalW = 3 * cartaW + 2 * espacio;&#10;        int startX = (int)((VIRTUAL_WIDTH - totalW) / 2);&#10;&#10;        int yAbajo = 40;&#10;        int yArriba = (int)(VIRTUAL_HEIGHT - cartaH - 40);&#10;&#10;        for (int i = 0; i &lt; 3; i++) {&#10;            cartaPos[i] = new Vector2(startX + i * (cartaW + espacio), yAbajo);&#10;            cartaVel[i] = new Vector2(0, 0);&#10;            cartaAcel[i] = new Vector2(0, 0);&#10;            cartaArrastrando[i] = false;&#10;        }&#10;        for (int i = 3; i &lt; NUM_CARTAS; i++) {&#10;            cartaPos[i] = new Vector2(startX + (i-3) * (cartaW + espacio), yArriba);&#10;            cartaVel[i] = new Vector2(0, 0);&#10;            cartaAcel[i] = new Vector2(0, 0);&#10;            cartaArrastrando[i] = false;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void render(float delta) {&#10;        viewport.apply();&#10;        batch.setProjectionMatrix(viewport.getCamera().combined);&#10;        shapeRenderer.setProjectionMatrix(viewport.getCamera().combined);&#10;&#10;        Gdx.gl.glClearColor(0, 0.1f, 0, 1);&#10;        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);&#10;&#10;        manejarInput();&#10;&#10;        // Físicas entre cartas (solo si no están jugadas)&#10;        for (int i = 0; i &lt; NUM_CARTAS; i++) {&#10;            if (cartaArrastrando[i] || cartaJugada[i]) continue;&#10;            for (int j = 0; j &lt; NUM_CARTAS; j++) {&#10;                if (i == j || cartaArrastrando[j] || cartaJugada[j]) continue;&#10;                float cartaW = 100, cartaH = 150;&#10;                Vector2 centroA = new Vector2(cartaPos[i].x + cartaW/2, cartaPos[i].y + cartaH/2);&#10;                Vector2 centroB = new Vector2(cartaPos[j].x + cartaW/2, cartaPos[j].y + cartaH/2);&#10;                float dist = centroA.dst(centroB);&#10;                if (dist &lt; CARTA_DISTANCIA_MIN) {&#10;                    Vector2 dir = new Vector2(centroA.x - centroB.x, centroA.y - centroB.y);&#10;                    if (dir.len() == 0) dir.set(MathUtils.random(-1f,1f), MathUtils.random(-1f,1f));&#10;                    dir.nor();&#10;                    float fuerza = (CARTA_DISTANCIA_MIN - dist) / CARTA_DISTANCIA_MIN * CARTA_REPELENCIA * delta;&#10;                    cartaPos[i].add(dir.scl(fuerza * 0.01f));&#10;                }&#10;            }&#10;        }&#10;&#10;        // Dibuja fondo de partida y casilla&#10;        batch.begin();&#10;        batch.draw(fondoPartida, 0, 0, VIRTUAL_WIDTH, VIRTUAL_HEIGHT);&#10;        batch.end();&#10;&#10;        // Fondo gris semitransparente de la casilla&#10;        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);&#10;        shapeRenderer.setColor(0.3f, 0.3f, 0.3f, 0.45f);&#10;        dibujarRectRedondeado(shapeRenderer, casillaCartas.x, casillaCartas.y, casillaCartas.width, casillaCartas.height, 18f);&#10;        shapeRenderer.end();&#10;&#10;        // Dibuja la textura de la casilla&#10;        batch.begin();&#10;        if (casillaTexture != null) {&#10;            batch.draw(casillaTexture, casillaCartas.x, casillaCartas.y, casillaCartas.width, casillaCartas.height);&#10;        }&#10;        batch.end();&#10;&#10;        // Dibuja cartas jugadas en la casilla (al fondo)&#10;        batch.begin();&#10;        for (int i = 0; i &lt; NUM_CARTAS; i++) {&#10;            if (cartaJugada[i]) {&#10;                float cartaW = 100, cartaH = 150;&#10;                float cx = casillaCartas.x + (casillaCartas.width - cartaW)/2;&#10;                float cy = casillaCartas.y + (casillaCartas.height - cartaH)/2;&#10;                batch.end();&#10;                shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);&#10;                shapeRenderer.setColor(1, 1, 1, 1);&#10;                dibujarRectRedondeado(shapeRenderer, cx, cy, cartaW, cartaH, 14f);&#10;                shapeRenderer.end();&#10;                batch.begin();&#10;                batch.draw(cartasRecortadas[i], cx, cy, cartaW, cartaH);&#10;                if (marcoCartaTexture != null) {&#10;                    batch.draw(marcoCartaTexture, cx, cy, cartaW, cartaH);&#10;                }&#10;            }&#10;        }&#10;        batch.end();&#10;&#10;        // Dibuja cartas no jugadas (por arriba de la casilla)&#10;        for (int k = 0; k &lt; NUM_CARTAS; k++) {&#10;            if (cartaJugada[k]) continue;&#10;            float cartaW = 100, cartaH = 150;&#10;            shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);&#10;            shapeRenderer.setColor(1, 1, 1, 1);&#10;            dibujarRectRedondeado(shapeRenderer, cartaPos[k].x, cartaPos[k].y, cartaW, cartaH, 14f);&#10;            shapeRenderer.end();&#10;&#10;            batch.begin();&#10;            if (cartasRecortadas[k] != null &amp;&amp; cartasRecortadas[k].getRegionWidth() &gt; 0 &amp;&amp; cartasRecortadas[k].getRegionHeight() &gt; 0) {&#10;                batch.draw(cartasRecortadas[k], cartaPos[k].x, cartaPos[k].y, cartaW, cartaH);&#10;            }&#10;            if (marcoCartaTexture != null) {&#10;                batch.draw(marcoCartaTexture, cartaPos[k].x, cartaPos[k].y, cartaW, cartaH);&#10;            }&#10;            batch.end();&#10;        }&#10;&#10;        // Overlay de pausa&#10;        batch.begin();&#10;        if (estado == EstadoJuego.PAUSADO) {&#10;            batch.setColor(0, 0, 0, 0.5f);&#10;            batch.draw(getWhitePixel(), 0, 0, VIRTUAL_WIDTH, VIRTUAL_HEIGHT);&#10;            batch.setColor(Color.WHITE);&#10;        }&#10;        batch.end();&#10;    }&#10;&#10;    // Dibuja un rectángulo con esquinas redondeadas&#10;    private void dibujarRectRedondeado(ShapeRenderer sr, float x, float y, float w, float h, float r) {&#10;        // Centro&#10;        sr.rect(x + r, y + r, w - 2 * r, h - 2 * r);&#10;        // Lados&#10;        sr.rect(x + r, y, w - 2 * r, r); // abajo&#10;        sr.rect(x + r, y + h - r, w - 2 * r, r); // arriba&#10;        sr.rect(x, y + r, r, h - 2 * r); // izq&#10;        sr.rect(x + w - r, y + r, r, h - 2 * r); // der&#10;        // Esquinas&#10;        sr.arc(x + r, y + r, r, 180, 90); // abajo izq&#10;        sr.arc(x + w - r, y + r, r, 270, 90); // abajo der&#10;        sr.arc(x + w - r, y + h - r, r, 0, 90); // arriba der&#10;        sr.arc(x + r, y + h - r, r, 90, 90); // arriba izq&#10;    }&#10;&#10;    private void manejarInput() {&#10;        if (Gdx.input.isKeyJustPressed(Input.Keys.ESCAPE)) {&#10;            if (estado == EstadoJuego.JUGANDO) {&#10;                estado = EstadoJuego.PAUSADO;&#10;            } else if (estado == EstadoJuego.PAUSADO) {&#10;                estado = EstadoJuego.JUGANDO;&#10;            }&#10;        }&#10;        if (estado == EstadoJuego.PAUSADO &amp;&amp; Gdx.input.isKeyJustPressed(Input.Keys.M)) {&#10;            game.setScreen(new PantallaMenu(game));&#10;        }&#10;&#10;        Vector2 mouse = viewport.unproject(new Vector2(Gdx.input.getX(), Gdx.input.getY()));&#10;        if (Gdx.input.justTouched()) {&#10;            for (int i = 0; i &lt; NUM_CARTAS; i++) {&#10;                if (cartaJugada[i]) continue;&#10;                int cartaW = 100, cartaH = 150;&#10;                if (mouse.x &gt;= cartaPos[i].x &amp;&amp; mouse.x &lt;= cartaPos[i].x + cartaW &amp;&amp;&#10;                    mouse.y &gt;= cartaPos[i].y &amp;&amp; mouse.y &lt;= cartaPos[i].y + cartaH) {&#10;                    cartaArrastrando[i] = true;&#10;                    cartaSeleccionada = i;&#10;                    arrastreOffset.set(mouse.x - cartaPos[i].x, mouse.y - cartaPos[i].y);&#10;                    if (cartaClickSound != null) cartaClickSound.play(0.7f);&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;        if (Gdx.input.isTouched() &amp;&amp; cartaSeleccionada != -1) {&#10;            if (!cartaJugada[cartaSeleccionada]) {&#10;                cartaPos[cartaSeleccionada].set(mouse.x - arrastreOffset.x, mouse.y - arrastreOffset.y);&#10;            }&#10;        }&#10;        if (!Gdx.input.isTouched()) {&#10;            if (cartaSeleccionada != -1) {&#10;                int cartaW = 100, cartaH = 150;&#10;                Rectangle cartaRect = new Rectangle(&#10;                    cartaPos[cartaSeleccionada].x, cartaPos[cartaSeleccionada].y, cartaW, cartaH&#10;                );&#10;                if (cartaRect.overlaps(casillaCartas)) {&#10;                    cartaJugada[cartaSeleccionada] = true;&#10;                    cartaPos[cartaSeleccionada].set(&#10;                        casillaCartas.x + (casillaCartas.width - cartaW)/2,&#10;                        casillaCartas.y + (casillaCartas.height - cartaH)/2&#10;                    );&#10;                }&#10;                cartaArrastrando[cartaSeleccionada] = false;&#10;                cartaSeleccionada = -1;&#10;            }&#10;        }&#10;    }&#10;&#10;    // Evita que la carta seleccionada se superponga con las otras&#10;    private void ajustarPosicionCarta(int idx) {&#10;        int cartaW = 100, cartaH = 150;&#10;        for (int i = 0; i &lt; NUM_CARTAS; i++) {&#10;            if (i == idx) continue;&#10;            if (rectsSolapan(cartaPos[idx], cartaPos[i], cartaW, cartaH)) {&#10;                // Mueve la carta seleccionada a la posición más cercana libre (a la derecha)&#10;                float espacio = 20;&#10;                float nuevaX = cartaPos[i].x + cartaW + espacio;&#10;                if (nuevaX + cartaW &gt; VIRTUAL_WIDTH) {&#10;                    // Si se sale de pantalla, la mueve a la izquierda&#10;                    nuevaX = cartaPos[i].x - cartaW - espacio;&#10;                    if (nuevaX &lt; 0) nuevaX = 0;&#10;                }&#10;                cartaPos[idx].x = nuevaX;&#10;                // Opcional: también puedes ajustar Y si quieres&#10;            }&#10;        }&#10;    }&#10;&#10;    private boolean rectsSolapan(Vector2 a, Vector2 b, int w, int h) {&#10;        return a.x &lt; b.x + w &amp;&amp; a.x + w &gt; b.x &amp;&amp; a.y &lt; b.y + h &amp;&amp; a.y + h &gt; b.y;&#10;    }&#10;&#10;    // Textura 1x1 blanca para overlays&#10;    private Texture whitePixel;&#10;    private Texture getWhitePixel() {&#10;        if (whitePixel == null) {&#10;            com.badlogic.gdx.graphics.Pixmap pixmap = new com.badlogic.gdx.graphics.Pixmap(1,1, com.badlogic.gdx.graphics.Pixmap.Format.RGBA8888);&#10;            pixmap.setColor(Color.WHITE);&#10;            pixmap.fill();&#10;            whitePixel = new Texture(pixmap);&#10;            pixmap.dispose();&#10;        }&#10;        return whitePixel;&#10;    }&#10;&#10;    @Override&#10;    public void resize(int width, int height) {&#10;        if (viewport != null) {&#10;            viewport.update(width, height, true);&#10;        }&#10;    }&#10;&#10;&#10;    @Override&#10;    public void pause() {}&#10;&#10;    @Override&#10;    public void resume() {}&#10;&#10;    @Override&#10;    public void hide() {}&#10;&#10;    @Override&#10;    public void dispose() {&#10;        batch.dispose();&#10;        shapeRenderer.dispose();&#10;        barajaTexture.dispose();&#10;        if (whitePixel != null) whitePixel.dispose();&#10;        if(fondoPartida != null) fondoPartida.dispose();&#10;        if (cartaClickSound != null) cartaClickSound.dispose();&#10;        if (marcoCartaTexture != null) marcoCartaTexture.dispose();&#10;        if (casillaTexture != null) casillaTexture.dispose();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.Envit.Juego.pantallas;&#10;&#10;import com.Envit.Juego.Principal;&#10;import com.badlogic.gdx.Gdx;&#10;import com.badlogic.gdx.Screen;&#10;import com.badlogic.gdx.Input;&#10;import com.badlogic.gdx.graphics.Color;&#10;import com.badlogic.gdx.graphics.GL20;&#10;import com.badlogic.gdx.graphics.Texture;&#10;import com.badlogic.gdx.graphics.g2d.SpriteBatch;&#10;import com.badlogic.gdx.graphics.g2d.TextureRegion;&#10;import com.badlogic.gdx.math.MathUtils;&#10;import com.badlogic.gdx.utils.viewport.FitViewport;&#10;import com.badlogic.gdx.utils.viewport.Viewport;&#10;import com.badlogic.gdx.graphics.glutils.ShapeRenderer;&#10;import com.badlogic.gdx.math.Vector2;&#10;import com.badlogic.gdx.audio.Sound;&#10;import com.badlogic.gdx.math.Rectangle;&#10;&#10;public class PantallaPartida implements Screen {&#10;    private final Principal game;&#10;    private SpriteBatch batch;&#10;    private Texture barajaTexture;&#10;    private Texture fondoPartida;&#10;    private TextureRegion[][] cartas; // [fila][columna]&#10;    private int[][] cartasMostradas; // [3][2] -&gt; fila, columna&#10;    private Partida partida;&#10;    // Viewport para mantener relación de aspecto&#10;    private static final float VIRTUAL_WIDTH = 1000;&#10;    private static final float VIRTUAL_HEIGHT = 625;&#10;    private Viewport viewport;&#10;    private ShapeRenderer shapeRenderer;&#10;&#10;    // Gestión de estados&#10;    private enum EstadoJuego { JUGANDO, PAUSADO, FINALIZADO }&#10;    private EstadoJuego estado = EstadoJuego.JUGANDO;&#10;&#10;    // Ahora 6 cartas&#10;    private static final int NUM_CARTAS = 6;&#10;    private TextureRegion[] cartasRecortadas = new TextureRegion[NUM_CARTAS];&#10;    // Posiciones y arrastre&#10;    private Vector2[] cartaPos = new Vector2[NUM_CARTAS];&#10;    private boolean[] cartaArrastrando = new boolean[NUM_CARTAS];&#10;    private Vector2 arrastreOffset = new Vector2();&#10;    private int cartaSeleccionada = -1;&#10;&#10;    // Sonido al clickear carta&#10;    private Sound cartaClickSound;&#10;&#10;    // Posiciones objetivo para animación&#10;    private Vector2[] cartaPosObjetivo = new Vector2[NUM_CARTAS];&#10;&#10;    // Físicas para cartas&#10;    private Vector2[] cartaVel = new Vector2[NUM_CARTAS];&#10;    private Vector2[] cartaAcel = new Vector2[NUM_CARTAS];&#10;    private static final float CARTA_REPELENCIA = 42000f; // fuerza de repulsión entre cartas&#10;    private static final float CARTA_DISTANCIA_MIN = 100f; // distancia mínima antes de repeler&#10;&#10;    // Marco de carta&#10;    private Texture marcoCartaTexture;&#10;&#10;    // Casilla para jugar cartas&#10;    private Rectangle casillaCartas;&#10;&#10;    // Estado de cartas jugadas&#10;    private boolean[] cartaJugada = new boolean[NUM_CARTAS];&#10;&#10;    // Textura para la casilla&#10;    private Texture casillaTexture;&#10;&#10;    // Para apilar cartas jugadas en la casilla&#10;    private int[] ordenJugadas = new int[NUM_CARTAS];&#10;    private int numCartasJugadas = 0;&#10;&#10;    public PantallaPartida(Principal game) {&#10;&#10;        this.game = game;&#10;        this.partida = new Partida();&#10;&#10;&#10;    }&#10;&#10;    @Override&#10;    public void show() {&#10;        batch = new SpriteBatch();&#10;        shapeRenderer = new ShapeRenderer();&#10;        fondoPartida= new Texture(Gdx.files.internal(&quot;fondos/fondoPartida.png&quot;));&#10;        barajaTexture = new Texture(Gdx.files.internal(&quot;sprites/baraja2.png&quot;));&#10;        viewport = new FitViewport(VIRTUAL_WIDTH, VIRTUAL_HEIGHT);&#10;        recortarSeisCartas();&#10;        inicializarPosicionesCartas();&#10;        cartaClickSound = Gdx.audio.newSound(Gdx.files.internal(&quot;sounds/carta.wav&quot;));&#10;        marcoCartaTexture = new Texture(Gdx.files.internal(&quot;sprites/marcoCARTA.png&quot;));&#10;        casillaTexture = new Texture(Gdx.files.internal(&quot;sprites/casilla.png&quot;));&#10;        // Casilla centrada en el medio&#10;        float casillaW = 120, casillaH = 170;&#10;        casillaCartas = new Rectangle(&#10;            VIRTUAL_WIDTH/2f - casillaW/2,&#10;            VIRTUAL_HEIGHT/2f - casillaH/2,&#10;            casillaW,&#10;            casillaH&#10;        );&#10;        numCartasJugadas = 0;&#10;        for (int i = 0; i &lt; NUM_CARTAS; i++) {&#10;            cartaJugada[i] = false;&#10;            ordenJugadas[i] = -1;&#10;        }&#10;    }&#10;&#10;    // Recorta 6 cartas únicas&#10;    private void recortarSeisCartas() {&#10;        int cartaW = barajaTexture.getWidth() / 11;&#10;        int cartaH = barajaTexture.getHeight() / 4;&#10;        boolean[][] usadas = new boolean[4][11];&#10;        for (int i = 0; i &lt; NUM_CARTAS; i++) {&#10;            TextureRegion region = null;&#10;            int fila, col;&#10;            do {&#10;                fila = MathUtils.random(0, 3);&#10;                col = MathUtils.random(0, 10);&#10;            } while (usadas[fila][col]);&#10;            usadas[fila][col] = true;&#10;            region = new TextureRegion(barajaTexture, col * cartaW, fila * cartaH, cartaW, cartaH);&#10;            cartasRecortadas[i] = region;&#10;        }&#10;    }&#10;&#10;    // 3 cartas abajo, 3 arriba&#10;    private void inicializarPosicionesCartas() {&#10;        int cartaW = 100, cartaH = 150, espacio = 20;&#10;        int totalW = 3 * cartaW + 2 * espacio;&#10;        int startX = (int)((VIRTUAL_WIDTH - totalW) / 2);&#10;&#10;        int yAbajo = 40;&#10;        int yArriba = (int)(VIRTUAL_HEIGHT - cartaH - 40);&#10;&#10;        for (int i = 0; i &lt; 3; i++) {&#10;            cartaPos[i] = new Vector2(startX + i * (cartaW + espacio), yAbajo);&#10;            cartaVel[i] = new Vector2(0, 0);&#10;            cartaAcel[i] = new Vector2(0, 0);&#10;            cartaArrastrando[i] = false;&#10;        }&#10;        for (int i = 3; i &lt; NUM_CARTAS; i++) {&#10;            cartaPos[i] = new Vector2(startX + (i-3) * (cartaW + espacio), yArriba);&#10;            cartaVel[i] = new Vector2(0, 0);&#10;            cartaAcel[i] = new Vector2(0, 0);&#10;            cartaArrastrando[i] = false;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void render(float delta) {&#10;        viewport.apply();&#10;        batch.setProjectionMatrix(viewport.getCamera().combined);&#10;        shapeRenderer.setProjectionMatrix(viewport.getCamera().combined);&#10;&#10;        Gdx.gl.glClearColor(0, 0.1f, 0, 1);&#10;        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);&#10;&#10;        manejarInput();&#10;&#10;        // Físicas entre cartas (solo si no están jugadas)&#10;        for (int i = 0; i &lt; NUM_CARTAS; i++) {&#10;            if (cartaArrastrando[i] || cartaJugada[i]) continue;&#10;            for (int j = 0; j &lt; NUM_CARTAS; j++) {&#10;                if (i == j || cartaArrastrando[j] || cartaJugada[j]) continue;&#10;                float cartaW = 100, cartaH = 150;&#10;                Vector2 centroA = new Vector2(cartaPos[i].x + cartaW/2, cartaPos[i].y + cartaH/2);&#10;                Vector2 centroB = new Vector2(cartaPos[j].x + cartaW/2, cartaPos[j].y + cartaH/2);&#10;                float dist = centroA.dst(centroB);&#10;                if (dist &lt; CARTA_DISTANCIA_MIN) {&#10;                    Vector2 dir = new Vector2(centroA.x - centroB.x, centroA.y - centroB.y);&#10;                    if (dir.len() == 0) dir.set(MathUtils.random(-1f,1f), MathUtils.random(-1f,1f));&#10;                    dir.nor();&#10;                    float fuerza = (CARTA_DISTANCIA_MIN - dist) / CARTA_DISTANCIA_MIN * CARTA_REPELENCIA * delta;&#10;                    cartaPos[i].add(dir.scl(fuerza * 0.01f));&#10;                }&#10;            }&#10;        }&#10;&#10;        // Dibuja fondo de partida y casilla&#10;        batch.begin();&#10;        batch.draw(fondoPartida, 0, 0, VIRTUAL_WIDTH, VIRTUAL_HEIGHT);&#10;        batch.end();&#10;&#10;        // Fondo gris semitransparente de la casilla&#10;        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);&#10;        shapeRenderer.setColor(0.3f, 0.3f, 0.3f, 0.45f);&#10;        dibujarRectRedondeado(shapeRenderer, casillaCartas.x, casillaCartas.y, casillaCartas.width, casillaCartas.height, 18f);&#10;        shapeRenderer.end();&#10;&#10;        // Dibuja la textura de la casilla&#10;        batch.begin();&#10;        if (casillaTexture != null) {&#10;            batch.draw(casillaTexture, casillaCartas.x, casillaCartas.y, casillaCartas.width, casillaCartas.height);&#10;        }&#10;        batch.end();&#10;&#10;        // Dibuja cartas jugadas en la casilla (apiladas, la última arriba)&#10;        batch.begin();&#10;        float cartaW = 100, cartaH = 150;&#10;        float cx = casillaCartas.x + (casillaCartas.width - cartaW)/2;&#10;        float cy = casillaCartas.y + (casillaCartas.height - cartaH)/2;&#10;        for (int k = 0; k &lt; numCartasJugadas; k++) {&#10;            int idx = ordenJugadas[k];&#10;            batch.end();&#10;            shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);&#10;            shapeRenderer.setColor(1, 1, 1, 1);&#10;            dibujarRectRedondeado(shapeRenderer, cx, cy, cartaW, cartaH, 14f);&#10;            shapeRenderer.end();&#10;            batch.begin();&#10;            batch.draw(cartasRecortadas[idx], cx, cy, cartaW, cartaH);&#10;            if (marcoCartaTexture != null) {&#10;                batch.draw(marcoCartaTexture, cx, cy, cartaW, cartaH);&#10;            }&#10;        }&#10;        batch.end();&#10;&#10;        // Dibuja cartas no jugadas (por arriba de la casilla y apiladas entre sí)&#10;        for (int k = 0; k &lt; NUM_CARTAS; k++) {&#10;            if (cartaJugada[k]) continue;&#10;            float x = cartaPos[k].x, y = cartaPos[k].y;&#10;            shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);&#10;            shapeRenderer.setColor(1, 1, 1, 1);&#10;            dibujarRectRedondeado(shapeRenderer, x, y, cartaW, cartaH, 14f);&#10;            shapeRenderer.end();&#10;&#10;            batch.begin();&#10;            if (cartasRecortadas[k] != null &amp;&amp; cartasRecortadas[k].getRegionWidth() &gt; 0 &amp;&amp; cartasRecortadas[k].getRegionHeight() &gt; 0) {&#10;                batch.draw(cartasRecortadas[k], x, y, cartaW, cartaH);&#10;            }&#10;            if (marcoCartaTexture != null) {&#10;                batch.draw(marcoCartaTexture, x, y, cartaW, cartaH);&#10;            }&#10;            batch.end();&#10;        }&#10;&#10;        // Overlay de pausa&#10;        batch.begin();&#10;        if (estado == EstadoJuego.PAUSADO) {&#10;            batch.setColor(0, 0, 0, 0.5f);&#10;            batch.draw(getWhitePixel(), 0, 0, VIRTUAL_WIDTH, VIRTUAL_HEIGHT);&#10;            batch.setColor(Color.WHITE);&#10;        }&#10;        batch.end();&#10;    }&#10;&#10;    // Dibuja un rectángulo con esquinas redondeadas&#10;    private void dibujarRectRedondeado(ShapeRenderer sr, float x, float y, float w, float h, float r) {&#10;        // Centro&#10;        sr.rect(x + r, y + r, w - 2 * r, h - 2 * r);&#10;        // Lados&#10;        sr.rect(x + r, y, w - 2 * r, r); // abajo&#10;        sr.rect(x + r, y + h - r, w - 2 * r, r); // arriba&#10;        sr.rect(x, y + r, r, h - 2 * r); // izq&#10;        sr.rect(x + w - r, y + r, r, h - 2 * r); // der&#10;        // Esquinas&#10;        sr.arc(x + r, y + r, r, 180, 90); // abajo izq&#10;        sr.arc(x + w - r, y + r, r, 270, 90); // abajo der&#10;        sr.arc(x + w - r, y + h - r, r, 0, 90); // arriba der&#10;        sr.arc(x + r, y + h - r, r, 90, 90); // arriba izq&#10;    }&#10;&#10;    private void manejarInput() {&#10;        if (Gdx.input.isKeyJustPressed(Input.Keys.ESCAPE)) {&#10;            if (estado == EstadoJuego.JUGANDO) {&#10;                estado = EstadoJuego.PAUSADO;&#10;            } else if (estado == EstadoJuego.PAUSADO) {&#10;                estado = EstadoJuego.JUGANDO;&#10;            }&#10;        }&#10;        if (estado == EstadoJuego.PAUSADO &amp;&amp; Gdx.input.isKeyJustPressed(Input.Keys.M)) {&#10;            game.setScreen(new PantallaMenu(game));&#10;        }&#10;&#10;        Vector2 mouse = viewport.unproject(new Vector2(Gdx.input.getX(), Gdx.input.getY()));&#10;        if (Gdx.input.justTouched()) {&#10;            for (int i = 0; i &lt; NUM_CARTAS; i++) {&#10;                if (cartaJugada[i]) continue;&#10;                int cartaW = 100, cartaH = 150;&#10;                if (mouse.x &gt;= cartaPos[i].x &amp;&amp; mouse.x &lt;= cartaPos[i].x + cartaW &amp;&amp;&#10;                    mouse.y &gt;= cartaPos[i].y &amp;&amp; mouse.y &lt;= cartaPos[i].y + cartaH) {&#10;                    cartaArrastrando[i] = true;&#10;                    cartaSeleccionada = i;&#10;                    arrastreOffset.set(mouse.x - cartaPos[i].x, mouse.y - cartaPos[i].y);&#10;                    if (cartaClickSound != null) cartaClickSound.play(0.7f);&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;        if (Gdx.input.isTouched() &amp;&amp; cartaSeleccionada != -1) {&#10;            if (!cartaJugada[cartaSeleccionada]) {&#10;                cartaPos[cartaSeleccionada].set(mouse.x - arrastreOffset.x, mouse.y - arrastreOffset.y);&#10;            }&#10;        }&#10;        if (!Gdx.input.isTouched()) {&#10;            if (cartaSeleccionada != -1) {&#10;                int cartaW = 100, cartaH = 150;&#10;                Rectangle cartaRect = new Rectangle(&#10;                    cartaPos[cartaSeleccionada].x, cartaPos[cartaSeleccionada].y, cartaW, cartaH&#10;                );&#10;                if (cartaRect.overlaps(casillaCartas)) {&#10;                    cartaJugada[cartaSeleccionada] = true;&#10;                    // Apila la carta en la casilla&#10;                    ordenJugadas[numCartasJugadas] = cartaSeleccionada;&#10;                    numCartasJugadas++;&#10;                    cartaPos[cartaSeleccionada].set(&#10;                        casillaCartas.x + (casillaCartas.width - cartaW)/2,&#10;                        casillaCartas.y + (casillaCartas.height - cartaH)/2&#10;                    );&#10;                }&#10;                cartaArrastrando[cartaSeleccionada] = false;&#10;                cartaSeleccionada = -1;&#10;            }&#10;        }&#10;    }&#10;&#10;    // Evita que la carta seleccionada se superponga con las otras&#10;    private void ajustarPosicionCarta(int idx) {&#10;        int cartaW = 100, cartaH = 150;&#10;        for (int i = 0; i &lt; NUM_CARTAS; i++) {&#10;            if (i == idx) continue;&#10;            if (rectsSolapan(cartaPos[idx], cartaPos[i], cartaW, cartaH)) {&#10;                // Mueve la carta seleccionada a la posición más cercana libre (a la derecha)&#10;                float espacio = 20;&#10;                float nuevaX = cartaPos[i].x + cartaW + espacio;&#10;                if (nuevaX + cartaW &gt; VIRTUAL_WIDTH) {&#10;                    // Si se sale de pantalla, la mueve a la izquierda&#10;                    nuevaX = cartaPos[i].x - cartaW - espacio;&#10;                    if (nuevaX &lt; 0) nuevaX = 0;&#10;                }&#10;                cartaPos[idx].x = nuevaX;&#10;                // Opcional: también puedes ajustar Y si quieres&#10;            }&#10;        }&#10;    }&#10;&#10;    private boolean rectsSolapan(Vector2 a, Vector2 b, int w, int h) {&#10;        return a.x &lt; b.x + w &amp;&amp; a.x + w &gt; b.x &amp;&amp; a.y &lt; b.y + h &amp;&amp; a.y + h &gt; b.y;&#10;    }&#10;&#10;    // Textura 1x1 blanca para overlays&#10;    private Texture whitePixel;&#10;    private Texture getWhitePixel() {&#10;        if (whitePixel == null) {&#10;            com.badlogic.gdx.graphics.Pixmap pixmap = new com.badlogic.gdx.graphics.Pixmap(1,1, com.badlogic.gdx.graphics.Pixmap.Format.RGBA8888);&#10;            pixmap.setColor(Color.WHITE);&#10;            pixmap.fill();&#10;            whitePixel = new Texture(pixmap);&#10;            pixmap.dispose();&#10;        }&#10;        return whitePixel;&#10;    }&#10;&#10;    @Override&#10;    public void resize(int width, int height) {&#10;        if (viewport != null) {&#10;            viewport.update(width, height, true);&#10;        }&#10;    }&#10;&#10;&#10;    @Override&#10;    public void pause() {}&#10;&#10;    @Override&#10;    public void resume() {}&#10;&#10;    @Override&#10;    public void hide() {}&#10;&#10;    @Override&#10;    public void dispose() {&#10;        batch.dispose();&#10;        shapeRenderer.dispose();&#10;        barajaTexture.dispose();&#10;        if (whitePixel != null) whitePixel.dispose();&#10;        if(fondoPartida != null) fondoPartida.dispose();&#10;        if (cartaClickSound != null) cartaClickSound.dispose();&#10;        if (marcoCartaTexture != null) marcoCartaTexture.dispose();&#10;        if (casillaTexture != null) casillaTexture.dispose();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>