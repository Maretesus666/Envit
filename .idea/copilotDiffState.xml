<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/core/src/main/java/com.Envit.Juego/pantallas/PantallaMenu.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/src/main/java/com.Envit.Juego/pantallas/PantallaMenu.java" />
              <option name="originalContent" value="package com.Envit.Juego.pantallas;&#10;&#10;import com.Envit.Juego.Principal;&#10;import com.badlogic.gdx.Gdx;&#10;import com.badlogic.gdx.Screen;&#10;import com.badlogic.gdx.graphics.*;&#10;import com.badlogic.gdx.graphics.g2d.*;&#10;import com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator;&#10;import com.badlogic.gdx.graphics.glutils.ShapeRenderer;&#10;import com.badlogic.gdx.math.Rectangle;&#10;&#10;import java.util.Random;&#10;&#10;public class PantallaMenu implements Screen {&#10;&#10;    private final Principal game;&#10;&#10;    private SpriteBatch batch;&#10;    private ShapeRenderer shapeRenderer;&#10;    private BitmapFont font;&#10;&#10;    private Texture backgroundTexture;&#10;    private Texture optionsBackgroundTexture;&#10;&#10;    private boolean inOptionsMode = false;&#10;&#10;    // Efectos CRT&#10;    private boolean crtEnabled = true;&#10;    private boolean flickerEnabled = true;&#10;    private boolean shakeEnabled = true;&#10;&#10;    private float scanlineOffset = 0f;&#10;    private float crtFlicker = 0f;&#10;&#10;    private Random random = new Random();&#10;&#10;    // UI&#10;    // Eliminados: TextButton, CheckBox, Label, Skin&#10;    // En su lugar, usaremos tus propios assets y lógica manual&#10;&#10;    // Ejemplo de posiciones para tus botones&#10;    private Rectangle btnPlayRect = new Rectangle();&#10;    private Rectangle btnOptionsRect = new Rectangle();&#10;    private Rectangle btnExitRect = new Rectangle();&#10;    private Rectangle btnCloseOptionsRect = new Rectangle();&#10;    private Rectangle chkCRTBox = new Rectangle();&#10;    private Rectangle chkFlickerBox = new Rectangle();&#10;    private Rectangle chkShakeBox = new Rectangle();&#10;&#10;    // Texturas para tus botones (deberás poner los nombres correctos de tus archivos)&#10;    private Texture btnPlayTexture, btnOptionsTexture, btnExitTexture, btnCloseOptionsTexture;&#10;    private Texture chkCheckedTexture, chkUncheckedTexture;&#10;    private Texture titleTexture;&#10;&#10;    public PantallaMenu(final Principal game) {&#10;        this.game = game;&#10;&#10;        batch = new SpriteBatch();&#10;        shapeRenderer = new ShapeRenderer();&#10;&#10;        // Stage eliminado, ya no se usa Scene2D&#10;        // Cargar tus texturas personalizadas&#10;        loadFont();&#10;        loadBackgrounds();&#10;        loadButtonTextures();&#10;        setButtonRects();&#10;    }&#10;&#10;    private void loadFont() {&#10;        try {&#10;            // Quitar &quot;assets/&quot; de la ruta, solo poner la ruta relativa desde assets&#10;            FreeTypeFontGenerator generator = new FreeTypeFontGenerator(Gdx.files.internal(&quot;fuentes/medieval.ttf&quot;));&#10;            FreeTypeFontGenerator.FreeTypeFontParameter parameter = new FreeTypeFontGenerator.FreeTypeFontParameter();&#10;            parameter.size = 36;&#10;            font = generator.generateFont(parameter);&#10;            generator.dispose();&#10;        } catch (Exception e) {&#10;            font = new BitmapFont(); // fallback default&#10;            Gdx.app.log(&quot;PantallaMenu&quot;, &quot;No se pudo cargar la fuente medieval.ttf, usando fuente por defecto&quot;);&#10;        }&#10;    }&#10;&#10;    private void loadBackgrounds() {&#10;        // Quitar &quot;assets/&quot; de la ruta, solo poner la ruta relativa desde assets&#10;        if (Gdx.files.internal(&quot;fondos/fondo.png&quot;).exists()) {&#10;            backgroundTexture = new Texture(Gdx.files.internal(&quot;fondos/fondo.png&quot;));&#10;            Gdx.app.log(&quot;PantallaMenu&quot;, &quot;Fondo principal cargado correctamente&quot;);&#10;        } else {&#10;            backgroundTexture = null;&#10;            Gdx.app.error(&quot;PantallaMenu&quot;, &quot;No se encontró fondos/fondo.png, usando fondo procedural&quot;);&#10;        }&#10;        if (Gdx.files.internal(&quot;fondos/fondoOpciones.png&quot;).exists()) {&#10;            optionsBackgroundTexture = new Texture(Gdx.files.internal(&quot;fondos/fondoOpciones.png&quot;));&#10;            Gdx.app.log(&quot;PantallaMenu&quot;, &quot;Fondo de opciones cargado correctamente&quot;);&#10;        } else {&#10;            optionsBackgroundTexture = null;&#10;            Gdx.app.error(&quot;PantallaMenu&quot;, &quot;No se encontró fondos/fondoOpciones.png, usando fondo procedural para opciones&quot;);&#10;        }&#10;    }&#10;&#10;    private void loadButtonTextures() {&#10;        // Cambia los nombres por los de tus archivos reales&#10;        btnPlayTexture = tryLoadTexture(&quot;sprites/btn_jugar.png&quot;);&#10;        btnOptionsTexture = tryLoadTexture(&quot;sprites/btn_opciones.png&quot;);&#10;        btnExitTexture = tryLoadTexture(&quot;sprites/btn_salir.png&quot;);&#10;        btnCloseOptionsTexture = tryLoadTexture(&quot;sprites/btn_cerrar.png&quot;);&#10;        chkCheckedTexture = tryLoadTexture(&quot;sprites/chk_on.png&quot;);&#10;        chkUncheckedTexture = tryLoadTexture(&quot;sprites/chk_off.png&quot;);&#10;        titleTexture = tryLoadTexture(&quot;sprites/titulo.png&quot;);&#10;    }&#10;&#10;    private Texture tryLoadTexture(String path) {&#10;        if (Gdx.files.internal(path).exists()) {&#10;            return new Texture(Gdx.files.internal(path));&#10;        } else {&#10;            Gdx.app.error(&quot;PantallaMenu&quot;, &quot;No se encontró: &quot; + path);&#10;            return null;&#10;        }&#10;    }&#10;&#10;    private void setButtonRects() {&#10;        int w = Gdx.graphics.getWidth();&#10;        int h = Gdx.graphics.getHeight();&#10;        float btnW = 200, btnH = 50;&#10;        float centerX = w / 2f - btnW / 2f;&#10;        btnPlayRect.set(centerX, 400, btnW, btnH);&#10;        btnOptionsRect.set(centerX, 320, btnW, btnH);&#10;        btnExitRect.set(centerX, 240, btnW, btnH);&#10;        btnCloseOptionsRect.set(centerX, 180, btnW, btnH);&#10;        // Checkboxes&#10;        float chkW = 32, chkH = 32;&#10;        float chkX = w / 2f - 100;&#10;        chkCRTBox.set(chkX, 320, chkW, chkH);&#10;        chkFlickerBox.set(chkX, 280, chkW, chkH);&#10;        chkShakeBox.set(chkX, 240, chkW, chkH);&#10;    }&#10;&#10;    @Override&#10;    public void resize(int width, int height) {&#10;        setButtonRects();&#10;    }&#10;&#10;    @Override&#10;    public void render(float delta) {&#10;        // Actualizar lógica efectos CRT&#10;        if (crtEnabled) {&#10;            scanlineOffset += 60 * delta * 0.5f;&#10;            if (scanlineOffset &gt; 4) scanlineOffset = 0;&#10;        }&#10;&#10;        if (flickerEnabled) {&#10;            crtFlicker += 60 * delta * 0.1f;&#10;            if (crtFlicker &gt; Math.PI * 2) crtFlicker = 0;&#10;        }&#10;&#10;        // Limpiar pantalla&#10;        Gdx.gl.glClearColor(0, 0, 0, 1);&#10;        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);&#10;&#10;        batch.begin();&#10;&#10;        // Dibujar fondo (según modo)&#10;        if (!inOptionsMode) {&#10;            if (backgroundTexture != null) {&#10;                batch.draw(backgroundTexture, 0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());&#10;            } else {&#10;                drawProceduralBackground(batch);&#10;            }&#10;        } else {&#10;            if (optionsBackgroundTexture != null) {&#10;                batch.draw(optionsBackgroundTexture, 0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());&#10;            } else {&#10;                drawProceduralOptionsBackground(batch);&#10;            }&#10;        }&#10;&#10;        // Dibuja el título&#10;        if (titleTexture != null) {&#10;            batch.draw(titleTexture, Gdx.graphics.getWidth()/2f - titleTexture.getWidth()/2f, Gdx.graphics.getHeight() - 120);&#10;        } else if (font != null) {&#10;            font.setColor(Color.CYAN);&#10;            font.getData().setScale(2f);&#10;            font.draw(batch, &quot;Envit&quot;, Gdx.graphics.getWidth()/2f - 80, Gdx.graphics.getHeight() - 80);&#10;        }&#10;&#10;        // Dibuja los botones principales&#10;        if (!inOptionsMode) {&#10;            drawButton(batch, btnPlayTexture, btnPlayRect, &quot;JUGAR&quot;);&#10;            drawButton(batch, btnOptionsTexture, btnOptionsRect, &quot;OPCIONES&quot;);&#10;            drawButton(batch, btnExitTexture, btnExitRect, &quot;SALIR&quot;);&#10;        } else {&#10;            drawButton(batch, btnCloseOptionsTexture, btnCloseOptionsRect, &quot;CERRAR&quot;);&#10;            // Checkboxes&#10;            drawCheckbox(batch, chkCRTBox, crtEnabled, &quot;Efectos CRT&quot;);&#10;            drawCheckbox(batch, chkFlickerBox, flickerEnabled, &quot;Destellos&quot;);&#10;            drawCheckbox(batch, chkShakeBox, shakeEnabled, &quot;Temblor&quot;);&#10;        }&#10;        batch.end();&#10;&#10;        // Dibujar efecto CRT&#10;        if (crtEnabled) {&#10;            drawCRTEffect();&#10;        }&#10;&#10;        // Manejo de input manual para botones y checkboxes&#10;        handleInput();&#10;    }&#10;&#10;    private void drawButton(SpriteBatch batch, Texture texture, Rectangle rect, String texto) {&#10;        boolean hovered = rect.contains(Gdx.input.getX(), Gdx.graphics.getHeight() - Gdx.input.getY());&#10;        if (texture != null) {&#10;            batch.setColor(hovered ? Color.CYAN : Color.WHITE);&#10;            batch.draw(texture, rect.x, rect.y, rect.width, rect.height);&#10;            batch.setColor(Color.WHITE);&#10;        } else if (font != null) {&#10;            // Fondo simple para el botón&#10;            batch.setColor(hovered ? new Color(0,1,1,0.5f) : new Color(0,0,0,0.5f));&#10;            batch.draw(getWhitePixel(), rect.x, rect.y, rect.width, rect.height);&#10;            batch.setColor(Color.WHITE);&#10;            font.setColor(hovered ? Color.CYAN : Color.WHITE);&#10;            font.getData().setScale(1.2f);&#10;            font.draw(batch, texto, rect.x + rect.width/2 - 50, rect.y + rect.height/2 + 15);&#10;        }&#10;    }&#10;&#10;    private void drawCheckbox(SpriteBatch batch, Rectangle rect, boolean checked, String label) {&#10;        boolean hovered = rect.contains(Gdx.input.getX(), Gdx.graphics.getHeight() - Gdx.input.getY());&#10;        Texture tex = checked ? chkCheckedTexture : chkUncheckedTexture;&#10;        if (tex != null) {&#10;            batch.setColor(hovered ? Color.CYAN : Color.WHITE);&#10;            batch.draw(tex, rect.x, rect.y, rect.width, rect.height);&#10;            batch.setColor(Color.WHITE);&#10;        } else {&#10;            batch.setColor(hovered ? new Color(0,1,1,0.5f) : new Color(0,0,0,0.5f));&#10;            batch.draw(getWhitePixel(), rect.x, rect.y, rect.width, rect.height);&#10;            batch.setColor(Color.WHITE);&#10;        }&#10;        if (font != null) {&#10;            font.setColor(hovered ? Color.CYAN : Color.WHITE);&#10;            font.getData().setScale(1f);&#10;            font.draw(batch, label, rect.x + rect.width + 8, rect.y + rect.height - 8);&#10;        }&#10;    }&#10;&#10;    private void handleInput() {&#10;        if (Gdx.input.justTouched()) {&#10;            float x = Gdx.input.getX();&#10;            float y = Gdx.graphics.getHeight() - Gdx.input.getY();&#10;            if (!inOptionsMode) {&#10;                if (btnPlayRect.contains(x, y)) startGame();&#10;                else if (btnOptionsRect.contains(x, y)) toggleOptions();&#10;                else if (btnExitRect.contains(x, y)) Gdx.app.exit();&#10;            } else {&#10;                if (btnCloseOptionsRect.contains(x, y)) toggleOptions();&#10;                else if (chkCRTBox.contains(x, y)) crtEnabled = !crtEnabled;&#10;                else if (chkFlickerBox.contains(x, y)) flickerEnabled = !flickerEnabled;&#10;                else if (chkShakeBox.contains(x, y)) shakeEnabled = !shakeEnabled;&#10;            }&#10;        }&#10;    }&#10;&#10;    private void toggleOptions() {&#10;        inOptionsMode = !inOptionsMode;&#10;    }&#10;&#10;    private void startGame() {&#10;        // Aquí llamás para cambiar de pantalla a la partida (ejemplo)&#10;        // game.setScreen(new PantallaPartida(game));&#10;&#10;        // Por ahora mostramos mensaje y volvemos al menú&#10;        Gdx.app.log(&quot;PantallaMenu&quot;, &quot;Iniciar partida - funcionalidad no implementada&quot;);&#10;    }&#10;&#10;    private void drawProceduralBackground(SpriteBatch batch) {&#10;        // Para algo simple, dibujamos un fondo con gradient manual (puede ser con ShapeRenderer si querés)&#10;        batch.end();&#10;&#10;        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);&#10;        int w = Gdx.graphics.getWidth();&#10;        int h = Gdx.graphics.getHeight();&#10;&#10;        // Gradient vertical manual simulando tu fondo original&#10;        shapeRenderer.rect(0, 0, w, h, new Color(0.04f, 0.04f, 0.12f,1), new Color(0.16f, 0.04f, 0.24f,1), new Color(0.24f, 0.08f, 0.39f,1), new Color(0.04f, 0.16f, 0.39f,1));&#10;&#10;        // Elementos gráficos retro simples&#10;        for (int i = 0; i &lt; 15; i++) {&#10;            float x = random.nextInt(w);&#10;            float y = random.nextInt(h);&#10;            float size = random.nextInt(150) + 50;&#10;            shapeRenderer.setColor(0, 1, 1, 0.12f);&#10;            shapeRenderer.circle(x, y, size);&#10;        }&#10;&#10;        // Líneas de circuito&#10;        shapeRenderer.setColor(1, 0, 1, 0.16f);&#10;        for (int i = 0; i &lt; 20; i++) {&#10;            float x1 = random.nextInt(w);&#10;            float y1 = random.nextInt(h);&#10;            float x2 = x1 + random.nextInt(200) - 100;&#10;            float y2 = y1 + random.nextInt(200) - 100;&#10;            shapeRenderer.rectLine(x1, y1, x2, y2, 2);&#10;        }&#10;&#10;        shapeRenderer.end();&#10;&#10;        batch.begin();&#10;    }&#10;&#10;    private void drawProceduralOptionsBackground(SpriteBatch batch) {&#10;        batch.end();&#10;&#10;        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);&#10;        int w = Gdx.graphics.getWidth();&#10;        int h = Gdx.graphics.getHeight();&#10;&#10;        // Gradientes para opciones (como en tu código)&#10;        // Parte 1&#10;        shapeRenderer.rect(0, 0, w / 2, h / 2, new Color(0.04f, 0.04f, 0.12f,1), new Color(0.16f, 0.04f, 0.24f,1), new Color(0.24f, 0.08f, 0.39f,1), new Color(0.04f, 0.16f, 0.39f,1));&#10;        // Parte 2&#10;        shapeRenderer.rect(w / 2, 0, w / 2, h, new Color(0.24f, 0.08f, 0.39f, 0.39f), new Color(0.08f, 0.16f, 0.39f, 0.39f), new Color(0.08f, 0.16f, 0.39f, 0.39f), new Color(0.24f, 0.08f, 0.39f, 0.39f));&#10;&#10;        shapeRenderer.end();&#10;&#10;        batch.begin();&#10;    }&#10;&#10;    private void drawCRTEffect() {&#10;        // batch.end(); // QUITADO: ya está terminado antes de llamar a este método&#10;&#10;        Gdx.gl.glEnable(GL20.GL_BLEND);&#10;        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);&#10;&#10;        int w = Gdx.graphics.getWidth();&#10;        int h = Gdx.graphics.getHeight();&#10;&#10;        // Líneas de escaneo horizontales&#10;        shapeRenderer.setColor(0, 0, 0, 0.15f);&#10;        for (int y = (int) scanlineOffset; y &lt; h; y += 3) {&#10;            shapeRenderer.rect(0, y, w, 1);&#10;        }&#10;&#10;        // Líneas verticales ocasionales&#10;        if (random.nextInt(50) &lt; 2) {&#10;            shapeRenderer.setColor(0, 0, 0, 0.08f);&#10;            for (int x = 0; x &lt; w; x += 2) {&#10;                shapeRenderer.rect(x, 0, 1, h);&#10;            }&#10;        }&#10;&#10;        shapeRenderer.end();&#10;&#10;        // batch.begin(); // QUITADO: el control de batch está en render()&#10;&#10;        // Flicker&#10;        if (flickerEnabled &amp;&amp; random.nextInt(100) &lt; 8) {&#10;            batch.begin();&#10;            Color flickerColor = new Color(1,1,1, 0.06f + 0.1f * (float)Math.sin(crtFlicker));&#10;            batch.setColor(flickerColor);&#10;            batch.draw(getWhitePixel(), 0, 0, w, h);&#10;            batch.setColor(Color.WHITE);&#10;            batch.end();&#10;        }&#10;&#10;        // Ruido estático&#10;        if (random.nextInt(150) &lt; 3) {&#10;            shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);&#10;            for (int i = 0; i &lt; 80; i++) {&#10;                float x = random.nextInt(w);&#10;                float y = random.nextInt(h);&#10;                float alpha = random.nextFloat() * 0.3f;&#10;                shapeRenderer.setColor(1, 1, 1, alpha);&#10;                shapeRenderer.rect(x, y, 2, 2);&#10;            }&#10;            shapeRenderer.end();&#10;        }&#10;&#10;        // Distorsión horizontal ocasional (temblor)&#10;        if (shakeEnabled &amp;&amp; random.nextInt(300) &lt; 2) {&#10;            shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);&#10;            int distortY = random.nextInt(h);&#10;            shapeRenderer.setColor(1, 1, 1, 0.12f);&#10;            shapeRenderer.rect(0, distortY, w, 3);&#10;            shapeRenderer.end();&#10;            batch.begin();&#10;        }&#10;    }&#10;&#10;    // Textura 1x1 blanca para dibujar rectángulos simples&#10;    private Texture whitePixel;&#10;&#10;    private Texture getWhitePixel() {&#10;        if (whitePixel == null) {&#10;            Pixmap pixmap = new Pixmap(1,1, Pixmap.Format.RGBA8888);&#10;            pixmap.setColor(Color.WHITE);&#10;            pixmap.fill();&#10;            whitePixel = new Texture(pixmap);&#10;            pixmap.dispose();&#10;        }&#10;        return whitePixel;&#10;    }&#10;&#10;    @Override&#10;    public void pause() {&#10;        // no necesario&#10;    }&#10;&#10;    @Override&#10;    public void resume() {&#10;        // no necesario&#10;    }&#10;&#10;    @Override&#10;    public void hide() {&#10;        // no necesario&#10;    }&#10;&#10;    @Override&#10;    public void show() {&#10;        // No es necesario implementar nada específico aquí para este menú&#10;    }&#10;&#10;    @Override&#10;    public void dispose() {&#10;        batch.dispose();&#10;        shapeRenderer.dispose();&#10;        if (backgroundTexture != null) backgroundTexture.dispose();&#10;        if (optionsBackgroundTexture != null) optionsBackgroundTexture.dispose();&#10;        if (whitePixel != null) whitePixel.dispose();&#10;        if (font != null) font.dispose();&#10;        if (btnPlayTexture != null) btnPlayTexture.dispose();&#10;        if (btnOptionsTexture != null) btnOptionsTexture.dispose();&#10;        if (btnExitTexture != null) btnExitTexture.dispose();&#10;        if (btnCloseOptionsTexture != null) btnCloseOptionsTexture.dispose();&#10;        if (chkCheckedTexture != null) chkCheckedTexture.dispose();&#10;        if (chkUncheckedTexture != null) chkUncheckedTexture.dispose();&#10;        if (titleTexture != null) titleTexture.dispose();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.Envit.Juego.pantallas;&#10;&#10;import com.Envit.Juego.Principal;&#10;import com.badlogic.gdx.Gdx;&#10;import com.badlogic.gdx.Screen;&#10;import com.badlogic.gdx.graphics.*;&#10;import com.badlogic.gdx.graphics.g2d.*;&#10;import com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator;&#10;import com.badlogic.gdx.graphics.glutils.ShapeRenderer;&#10;import com.badlogic.gdx.math.Rectangle;&#10;&#10;import java.util.Random;&#10;&#10;public class PantallaMenu implements Screen {&#10;&#10;    private final Principal game;&#10;&#10;    private SpriteBatch batch;&#10;    private ShapeRenderer shapeRenderer;&#10;    private BitmapFont font;&#10;&#10;    private Texture backgroundTexture;&#10;    private Texture optionsBackgroundTexture;&#10;&#10;    private boolean inOptionsMode = false;&#10;&#10;    // Efectos CRT&#10;    private boolean crtEnabled = true;&#10;    private boolean flickerEnabled = true;&#10;    private boolean shakeEnabled = true;&#10;&#10;    private float scanlineOffset = 0f;&#10;    private float crtFlicker = 0f;&#10;&#10;    private Random random = new Random();&#10;&#10;    // UI&#10;    // Eliminados: TextButton, CheckBox, Label, Skin&#10;    // En su lugar, usaremos tus propios assets y lógica manual&#10;&#10;    // Ejemplo de posiciones para tus botones&#10;    private Rectangle btnPlayRect = new Rectangle();&#10;    private Rectangle btnOptionsRect = new Rectangle();&#10;    private Rectangle btnExitRect = new Rectangle();&#10;    private Rectangle btnCloseOptionsRect = new Rectangle();&#10;    private Rectangle chkCRTBox = new Rectangle();&#10;    private Rectangle chkFlickerBox = new Rectangle();&#10;    private Rectangle chkShakeBox = new Rectangle();&#10;&#10;    // Texturas para tus botones (deberás poner los nombres correctos de tus archivos)&#10;    private Texture btnPlayTexture, btnOptionsTexture, btnExitTexture, btnCloseOptionsTexture;&#10;    private Texture chkCheckedTexture, chkUncheckedTexture;&#10;    private Texture titleTexture;&#10;&#10;    public PantallaMenu(final Principal game) {&#10;        this.game = game;&#10;&#10;        batch = new SpriteBatch();&#10;        shapeRenderer = new ShapeRenderer();&#10;&#10;        // Stage eliminado, ya no se usa Scene2D&#10;        // Cargar tus texturas personalizadas&#10;        loadFont();&#10;        loadBackgrounds();&#10;        loadButtonTextures();&#10;        setButtonRects();&#10;    }&#10;&#10;    private void loadFont() {&#10;        try {&#10;            // Quitar &quot;assets/&quot; de la ruta, solo poner la ruta relativa desde assets&#10;            FreeTypeFontGenerator generator = new FreeTypeFontGenerator(Gdx.files.internal(&quot;fuentes/medieval.ttf&quot;));&#10;            FreeTypeFontGenerator.FreeTypeFontParameter parameter = new FreeTypeFontGenerator.FreeTypeFontParameter();&#10;            parameter.size = 36;&#10;            font = generator.generateFont(parameter);&#10;            generator.dispose();&#10;        } catch (Exception e) {&#10;            font = new BitmapFont(); // fallback default&#10;            Gdx.app.log(&quot;PantallaMenu&quot;, &quot;No se pudo cargar la fuente medieval.ttf, usando fuente por defecto&quot;);&#10;        }&#10;    }&#10;&#10;    private void loadBackgrounds() {&#10;        // Quitar &quot;assets/&quot; de la ruta, solo poner la ruta relativa desde assets&#10;        if (Gdx.files.internal(&quot;fondos/fondo.png&quot;).exists()) {&#10;            backgroundTexture = new Texture(Gdx.files.internal(&quot;fondos/fondo.png&quot;));&#10;            Gdx.app.log(&quot;PantallaMenu&quot;, &quot;Fondo principal cargado correctamente&quot;);&#10;        } else {&#10;            backgroundTexture = null;&#10;            Gdx.app.error(&quot;PantallaMenu&quot;, &quot;No se encontró fondos/fondo.png, usando fondo procedural&quot;);&#10;        }&#10;        if (Gdx.files.internal(&quot;fondos/fondoOpciones.png&quot;).exists()) {&#10;            optionsBackgroundTexture = new Texture(Gdx.files.internal(&quot;fondos/fondoOpciones.png&quot;));&#10;            Gdx.app.log(&quot;PantallaMenu&quot;, &quot;Fondo de opciones cargado correctamente&quot;);&#10;        } else {&#10;            optionsBackgroundTexture = null;&#10;            Gdx.app.error(&quot;PantallaMenu&quot;, &quot;No se encontró fondos/fondoOpciones.png, usando fondo procedural para opciones&quot;);&#10;        }&#10;    }&#10;&#10;    private void loadButtonTextures() {&#10;        // Cambia los nombres por los de tus archivos reales&#10;        btnPlayTexture = tryLoadTexture(&quot;sprites/btn_jugar.png&quot;);&#10;        btnOptionsTexture = tryLoadTexture(&quot;sprites/btn_opciones.png&quot;);&#10;        btnExitTexture = tryLoadTexture(&quot;sprites/btn_salir.png&quot;);&#10;        btnCloseOptionsTexture = tryLoadTexture(&quot;sprites/btn_cerrar.png&quot;);&#10;        chkCheckedTexture = tryLoadTexture(&quot;sprites/chk_on.png&quot;);&#10;        chkUncheckedTexture = tryLoadTexture(&quot;sprites/chk_off.png&quot;);&#10;        titleTexture = tryLoadTexture(&quot;sprites/titulo.png&quot;);&#10;    }&#10;&#10;    private Texture tryLoadTexture(String path) {&#10;        if (Gdx.files.internal(path).exists()) {&#10;            return new Texture(Gdx.files.internal(path));&#10;        } else {&#10;            Gdx.app.error(&quot;PantallaMenu&quot;, &quot;No se encontró: &quot; + path);&#10;            return null;&#10;        }&#10;    }&#10;&#10;    private void setButtonRects() {&#10;        int w = Gdx.graphics.getWidth();&#10;        int h = Gdx.graphics.getHeight();&#10;        float btnW = 200, btnH = 50;&#10;        float centerX = w / 2f - btnW / 2f;&#10;        btnPlayRect.set(centerX, 400, btnW, btnH);&#10;        btnOptionsRect.set(centerX, 320, btnW, btnH);&#10;        btnExitRect.set(centerX, 240, btnW, btnH);&#10;        btnCloseOptionsRect.set(centerX, 180, btnW, btnH);&#10;        // Checkboxes&#10;        float chkW = 32, chkH = 32;&#10;        float chkX = w / 2f - 100;&#10;        chkCRTBox.set(chkX, 320, chkW, chkH);&#10;        chkFlickerBox.set(chkX, 280, chkW, chkH);&#10;        chkShakeBox.set(chkX, 240, chkW, chkH);&#10;    }&#10;&#10;    @Override&#10;    public void resize(int width, int height) {&#10;        setButtonRects();&#10;    }&#10;&#10;    @Override&#10;    public void render(float delta) {&#10;        // Actualizar lógica efectos CRT&#10;        if (crtEnabled) {&#10;            scanlineOffset += 60 * delta * 0.5f;&#10;            if (scanlineOffset &gt; 4) scanlineOffset = 0;&#10;        }&#10;&#10;        if (flickerEnabled) {&#10;            crtFlicker += 60 * delta * 0.1f;&#10;            if (crtFlicker &gt; Math.PI * 2) crtFlicker = 0;&#10;        }&#10;&#10;        // Limpiar pantalla&#10;        Gdx.gl.glClearColor(0, 0, 0, 1);&#10;        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);&#10;&#10;        batch.begin();&#10;&#10;        // Dibujar fondo (según modo)&#10;        if (!inOptionsMode) {&#10;            if (backgroundTexture != null) {&#10;                batch.draw(backgroundTexture, 0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());&#10;            } else {&#10;                drawProceduralBackground(batch);&#10;            }&#10;        } else {&#10;            if (optionsBackgroundTexture != null) {&#10;                batch.draw(optionsBackgroundTexture, 0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());&#10;            } else {&#10;                drawProceduralOptionsBackground(batch);&#10;            }&#10;        }&#10;&#10;        // Dibuja el título&#10;        if (titleTexture != null) {&#10;            batch.draw(titleTexture, Gdx.graphics.getWidth()/2f - titleTexture.getWidth()/2f, Gdx.graphics.getHeight() - 120);&#10;        } else if (font != null) {&#10;            font.setColor(Color.CYAN);&#10;            font.getData().setScale(2f);&#10;            font.draw(batch, &quot;Envit&quot;, Gdx.graphics.getWidth()/2f - 80, Gdx.graphics.getHeight() - 80);&#10;        }&#10;&#10;        // Dibuja los botones principales&#10;        if (!inOptionsMode) {&#10;            drawButton(batch, btnPlayTexture, btnPlayRect, &quot;JUGAR&quot;);&#10;            drawButton(batch, btnOptionsTexture, btnOptionsRect, &quot;OPCIONES&quot;);&#10;            drawButton(batch, btnExitTexture, btnExitRect, &quot;SALIR&quot;);&#10;        } else {&#10;            drawButton(batch, btnCloseOptionsTexture, btnCloseOptionsRect, &quot;CERRAR&quot;);&#10;            // Checkboxes&#10;            drawCheckbox(batch, chkCRTBox, crtEnabled, &quot;Efectos CRT&quot;);&#10;            drawCheckbox(batch, chkFlickerBox, flickerEnabled, &quot;Destellos&quot;);&#10;            drawCheckbox(batch, chkShakeBox, shakeEnabled, &quot;Temblor&quot;);&#10;        }&#10;        batch.end();&#10;&#10;        // Dibujar efecto CRT&#10;        if (crtEnabled) {&#10;            drawCRTEffect();&#10;        }&#10;&#10;        // Manejo de input manual para botones y checkboxes&#10;        handleInput();&#10;    }&#10;&#10;    private void drawButton(SpriteBatch batch, Texture texture, Rectangle rect, String texto) {&#10;        boolean hovered = rect.contains(Gdx.input.getX(), Gdx.graphics.getHeight() - Gdx.input.getY());&#10;        if (texture != null) {&#10;            batch.setColor(hovered ? Color.CYAN : Color.WHITE);&#10;            batch.draw(texture, rect.x, rect.y, rect.width, rect.height);&#10;            batch.setColor(Color.WHITE);&#10;        } else if (font != null) {&#10;            // Fondo simple para el botón&#10;            batch.setColor(hovered ? new Color(0,1,1,0.5f) : new Color(0,0,0,0.5f));&#10;            batch.draw(getWhitePixel(), rect.x, rect.y, rect.width, rect.height);&#10;            batch.setColor(Color.WHITE);&#10;            font.setColor(hovered ? Color.CYAN : Color.WHITE);&#10;            font.getData().setScale(1.2f);&#10;            font.draw(batch, texto, rect.x + rect.width/2 - 50, rect.y + rect.height/2 + 15);&#10;        }&#10;    }&#10;&#10;    private void drawCheckbox(SpriteBatch batch, Rectangle rect, boolean checked, String label) {&#10;        boolean hovered = rect.contains(Gdx.input.getX(), Gdx.graphics.getHeight() - Gdx.input.getY());&#10;        Texture tex = checked ? chkCheckedTexture : chkUncheckedTexture;&#10;        if (tex != null) {&#10;            batch.setColor(hovered ? Color.CYAN : Color.WHITE);&#10;            batch.draw(tex, rect.x, rect.y, rect.width, rect.height);&#10;            batch.setColor(Color.WHITE);&#10;        } else {&#10;            batch.setColor(hovered ? new Color(0,1,1,0.5f) : new Color(0,0,0,0.5f));&#10;            batch.draw(getWhitePixel(), rect.x, rect.y, rect.width, rect.height);&#10;            batch.setColor(Color.WHITE);&#10;        }&#10;        if (font != null) {&#10;            font.setColor(hovered ? Color.CYAN : Color.WHITE);&#10;            font.getData().setScale(1f);&#10;            font.draw(batch, label, rect.x + rect.width + 8, rect.y + rect.height - 8);&#10;        }&#10;    }&#10;&#10;    private void handleInput() {&#10;        if (Gdx.input.justTouched()) {&#10;            float x = Gdx.input.getX();&#10;            float y = Gdx.graphics.getHeight() - Gdx.input.getY();&#10;            if (!inOptionsMode) {&#10;                if (btnPlayRect.contains(x, y)) startGame();&#10;                else if (btnOptionsRect.contains(x, y)) toggleOptions();&#10;                else if (btnExitRect.contains(x, y)) Gdx.app.exit();&#10;            } else {&#10;                if (btnCloseOptionsRect.contains(x, y)) toggleOptions();&#10;                else if (chkCRTBox.contains(x, y)) crtEnabled = !crtEnabled;&#10;                else if (chkFlickerBox.contains(x, y)) flickerEnabled = !flickerEnabled;&#10;                else if (chkShakeBox.contains(x, y)) shakeEnabled = !shakeEnabled;&#10;            }&#10;        }&#10;    }&#10;&#10;    private void toggleOptions() {&#10;        inOptionsMode = !inOptionsMode;&#10;    }&#10;&#10;    private void startGame() {&#10;        // Aquí llamás para cambiar de pantalla a la partida (ejemplo)&#10;        // game.setScreen(new PantallaPartida(game));&#10;&#10;        // Por ahora mostramos mensaje y volvemos al menú&#10;        Gdx.app.log(&quot;PantallaMenu&quot;, &quot;Iniciar partida - funcionalidad no implementada&quot;);&#10;    }&#10;&#10;    private void drawProceduralBackground(SpriteBatch batch) {&#10;        // Para algo simple, dibujamos un fondo con gradient manual (puede ser con ShapeRenderer si querés)&#10;        batch.end();&#10;&#10;        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);&#10;        int w = Gdx.graphics.getWidth();&#10;        int h = Gdx.graphics.getHeight();&#10;&#10;        // Gradient vertical manual simulando tu fondo original&#10;        shapeRenderer.rect(0, 0, w, h, new Color(0.04f, 0.04f, 0.12f,1), new Color(0.16f, 0.04f, 0.24f,1), new Color(0.24f, 0.08f, 0.39f,1), new Color(0.04f, 0.16f, 0.39f,1));&#10;&#10;        // Elementos gráficos retro simples&#10;        for (int i = 0; i &lt; 15; i++) {&#10;            float x = random.nextInt(w);&#10;            float y = random.nextInt(h);&#10;            float size = random.nextInt(150) + 50;&#10;            shapeRenderer.setColor(0, 1, 1, 0.12f);&#10;            shapeRenderer.circle(x, y, size);&#10;        }&#10;&#10;        // Líneas de circuito&#10;        shapeRenderer.setColor(1, 0, 1, 0.16f);&#10;        for (int i = 0; i &lt; 20; i++) {&#10;            float x1 = random.nextInt(w);&#10;            float y1 = random.nextInt(h);&#10;            float x2 = x1 + random.nextInt(200) - 100;&#10;            float y2 = y1 + random.nextInt(200) - 100;&#10;            shapeRenderer.rectLine(x1, y1, x2, y2, 2);&#10;        }&#10;&#10;        shapeRenderer.end();&#10;&#10;        batch.begin();&#10;    }&#10;&#10;    private void drawProceduralOptionsBackground(SpriteBatch batch) {&#10;        batch.end();&#10;&#10;        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);&#10;        int w = Gdx.graphics.getWidth();&#10;        int h = Gdx.graphics.getHeight();&#10;&#10;        // Gradientes para opciones (como en tu código)&#10;        // Parte 1&#10;        shapeRenderer.rect(0, 0, w / 2, h / 2, new Color(0.04f, 0.04f, 0.12f,1), new Color(0.16f, 0.04f, 0.24f,1), new Color(0.24f, 0.08f, 0.39f,1), new Color(0.04f, 0.16f, 0.39f,1));&#10;        // Parte 2&#10;        shapeRenderer.rect(w / 2, 0, w / 2, h, new Color(0.24f, 0.08f, 0.39f, 0.39f), new Color(0.08f, 0.16f, 0.39f, 0.39f), new Color(0.08f, 0.16f, 0.39f, 0.39f), new Color(0.24f, 0.08f, 0.39f, 0.39f));&#10;&#10;        shapeRenderer.end();&#10;&#10;        batch.begin();&#10;    }&#10;&#10;    private void drawCRTEffect() {&#10;        // batch.end(); // QUITADO: ya está terminado antes de llamar a este método&#10;&#10;        Gdx.gl.glEnable(GL20.GL_BLEND);&#10;        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);&#10;&#10;        int w = Gdx.graphics.getWidth();&#10;        int h = Gdx.graphics.getHeight();&#10;&#10;        // Líneas de escaneo horizontales&#10;        shapeRenderer.setColor(0, 0, 0, 0.15f);&#10;        for (int y = (int) scanlineOffset; y &lt; h; y += 3) {&#10;            shapeRenderer.rect(0, y, w, 1);&#10;        }&#10;&#10;        // Líneas verticales ocasionales&#10;        if (random.nextInt(50) &lt; 2) {&#10;            shapeRenderer.setColor(0, 0, 0, 0.08f);&#10;            for (int x = 0; x &lt; w; x += 2) {&#10;                shapeRenderer.rect(x, 0, 1, h);&#10;            }&#10;        }&#10;&#10;        shapeRenderer.end();&#10;&#10;        // batch.begin(); // QUITADO: el control de batch está en render()&#10;&#10;        // Flicker&#10;        if (flickerEnabled &amp;&amp; random.nextInt(100) &lt; 8) {&#10;            batch.begin();&#10;            Color flickerColor = new Color(1,1,1, 0.06f + 0.1f * (float)Math.sin(crtFlicker));&#10;            batch.setColor(flickerColor);&#10;            batch.draw(getWhitePixel(), 0, 0, w, h);&#10;            batch.setColor(Color.WHITE);&#10;            batch.end();&#10;        }&#10;&#10;        // Ruido estático&#10;        if (random.nextInt(150) &lt; 3) {&#10;            shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);&#10;            for (int i = 0; i &lt; 80; i++) {&#10;                float x = random.nextInt(w);&#10;                float y = random.nextInt(h);&#10;                float alpha = random.nextFloat() * 0.3f;&#10;                shapeRenderer.setColor(1, 1, 1, alpha);&#10;                shapeRenderer.rect(x, y, 2, 2);&#10;            }&#10;            shapeRenderer.end();&#10;        }&#10;&#10;        // Distorsión horizontal ocasional (temblor)&#10;        if (shakeEnabled &amp;&amp; random.nextInt(300) &lt; 2) {&#10;            shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);&#10;            int distortY = random.nextInt(h);&#10;            shapeRenderer.setColor(1, 1, 1, 0.12f);&#10;            shapeRenderer.rect(0, distortY, w, 3);&#10;            shapeRenderer.end();&#10;        }&#10;    }&#10;&#10;    // Textura 1x1 blanca para dibujar rectángulos simples&#10;    private Texture whitePixel;&#10;&#10;    private Texture getWhitePixel() {&#10;        if (whitePixel == null) {&#10;            Pixmap pixmap = new Pixmap(1,1, Pixmap.Format.RGBA8888);&#10;            pixmap.setColor(Color.WHITE);&#10;            pixmap.fill();&#10;            whitePixel = new Texture(pixmap);&#10;            pixmap.dispose();&#10;        }&#10;        return whitePixel;&#10;    }&#10;&#10;    @Override&#10;    public void pause() {&#10;        // no necesario&#10;    }&#10;&#10;    @Override&#10;    public void resume() {&#10;        // no necesario&#10;    }&#10;&#10;    @Override&#10;    public void hide() {&#10;        // no necesario&#10;    }&#10;&#10;    @Override&#10;    public void show() {&#10;        // No es necesario implementar nada específico aquí para este menú&#10;    }&#10;&#10;    @Override&#10;    public void dispose() {&#10;        batch.dispose();&#10;        shapeRenderer.dispose();&#10;        if (backgroundTexture != null) backgroundTexture.dispose();&#10;        if (optionsBackgroundTexture != null) optionsBackgroundTexture.dispose();&#10;        if (whitePixel != null) whitePixel.dispose();&#10;        if (font != null) font.dispose();&#10;        if (btnPlayTexture != null) btnPlayTexture.dispose();&#10;        if (btnOptionsTexture != null) btnOptionsTexture.dispose();&#10;        if (btnExitTexture != null) btnExitTexture.dispose();&#10;        if (btnCloseOptionsTexture != null) btnCloseOptionsTexture.dispose();&#10;        if (chkCheckedTexture != null) chkCheckedTexture.dispose();&#10;        if (chkUncheckedTexture != null) chkUncheckedTexture.dispose();&#10;        if (titleTexture != null) titleTexture.dispose();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>