<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/core/src/com/mygdx/game/MainGame.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/src/com/mygdx/game/MainGame.java" />
              <option name="updatedContent" value="package com.mygdx.game;&#10;&#10;import com.badlogic.gdx.Game;&#10;&#10;public class MainGame extends Game {&#10;    @Override&#10;    public void create() {&#10;        setScreen(new PantallaMenu(this));&#10;    }&#10;    // ...resto del código...&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/src/com/mygdx/game/PantallaMenu.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/src/com/mygdx/game/PantallaMenu.java" />
              <option name="originalContent" value="package com.mygdx.game;&#10;&#10;import com.badlogic.gdx.Gdx;&#10;import com.badlogic.gdx.Screen;&#10;import com.badlogic.gdx.graphics.GL20;&#10;import com.badlogic.gdx.scenes.scene2d.Stage;&#10;import com.badlogic.gdx.scenes.scene2d.ui.Skin;&#10;import com.badlogic.gdx.scenes.scene2d.ui.TextButton;&#10;import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;&#10;import com.badlogic.gdx.scenes.scene2d.InputEvent;&#10;import com.badlogic.gdx.utils.viewport.ScreenViewport;&#10;&#10;public class PantallaMenu implements Screen {&#10;    private final MainGame game;&#10;    private Stage stage;&#10;    private Skin skin;&#10;&#10;    public PantallaMenu(MainGame game) {&#10;        this.game = game;&#10;    }&#10;&#10;    @Override&#10;    public void show() {&#10;        stage = new Stage(new ScreenViewport());&#10;        Gdx.input.setInputProcessor(stage);&#10;&#10;        skin = new Skin(Gdx.files.internal(&quot;uiskin.json&quot;)); // Asegúrate de tener este skin&#10;&#10;        TextButton jugarBtn = new TextButton(&quot;Jugar&quot;, skin);&#10;        jugarBtn.setSize(200, 60);&#10;        jugarBtn.setPosition(&#10;            Gdx.graphics.getWidth() / 2f - jugarBtn.getWidth() / 2,&#10;            Gdx.graphics.getHeight() / 2f - jugarBtn.getHeight() / 2&#10;        );&#10;        jugarBtn.addListener(new ClickListener() {&#10;            @Override&#10;            public void clicked(InputEvent event, float x, float y) {&#10;                game.setScreen(new PantallaPartida(game));&#10;            }&#10;        });&#10;&#10;        stage.addActor(jugarBtn);&#10;    }&#10;&#10;    @Override&#10;    public void render(float delta) {&#10;        Gdx.gl.glClearColor(0, 0, 0, 1);&#10;        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);&#10;        stage.act(delta);&#10;        stage.draw();&#10;    }&#10;&#10;    @Override&#10;    public void resize(int width, int height) {&#10;        stage.getViewport().update(width, height, true);&#10;    }&#10;&#10;    @Override&#10;    public void pause() {}&#10;&#10;    @Override&#10;    public void resume() {}&#10;&#10;    @Override&#10;    public void hide() {&#10;        stage.dispose();&#10;        skin.dispose();&#10;    }&#10;&#10;    @Override&#10;    public void dispose() {&#10;        stage.dispose();&#10;        skin.dispose();&#10;&#10;" />
              <option name="updatedContent" value="package com.mygdx.game;&#10;&#10;import com.badlogic.gdx.Gdx;&#10;import com.badlogic.gdx.Screen;&#10;import com.badlogic.gdx.graphics.GL20;&#10;import com.badlogic.gdx.scenes.scene2d.Stage;&#10;import com.badlogic.gdx.scenes.scene2d.ui.Skin;&#10;import com.badlogic.gdx.scenes.scene2d.ui.TextButton;&#10;import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;&#10;import com.badlogic.gdx.scenes.scene2d.InputEvent;&#10;import com.badlogic.gdx.utils.viewport.ScreenViewport;&#10;&#10;public class PantallaMenu implements Screen {&#10;    private final MainGame game;&#10;    private Stage stage;&#10;    private Skin skin;&#10;&#10;    public PantallaMenu(MainGame game) {&#10;        this.game = game;&#10;    }&#10;&#10;    @Override&#10;    public void show() {&#10;        stage = new Stage(new ScreenViewport());&#10;        Gdx.input.setInputProcessor(stage);&#10;&#10;        skin = new Skin(Gdx.files.internal(&quot;uiskin.json&quot;)); // Asegúrate de tener este skin&#10;&#10;        TextButton jugarBtn = new TextButton(&quot;Jugar&quot;, skin);&#10;        jugarBtn.setSize(200, 60);&#10;        jugarBtn.setPosition(&#10;            Gdx.graphics.getWidth() / 2f - jugarBtn.getWidth() / 2,&#10;            Gdx.graphics.getHeight() / 2f - jugarBtn.getHeight() / 2&#10;        );&#10;        jugarBtn.addListener(new ClickListener() {&#10;            @Override&#10;            public void clicked(InputEvent event, float x, float y) {&#10;                game.setScreen(new PantallaPartida(game));&#10;            }&#10;        });&#10;&#10;        stage.addActor(jugarBtn);&#10;    }&#10;&#10;    @Override&#10;    public void render(float delta) {&#10;        Gdx.gl.glClearColor(0, 0, 0, 1);&#10;        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);&#10;        stage.act(delta);&#10;        stage.draw();&#10;    }&#10;&#10;    @Override&#10;    public void resize(int width, int height) {&#10;        stage.getViewport().update(width, height, true);&#10;    }&#10;&#10;    @Override&#10;    public void pause() {}&#10;&#10;    @Override&#10;    public void resume() {}&#10;&#10;    @Override&#10;    public void hide() {&#10;        stage.dispose();&#10;        skin.dispose();&#10;    }&#10;&#10;    @Override&#10;    public void dispose() {&#10;        stage.dispose();&#10;        skin.dispose();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/src/com/mygdx/game/PantallaPartida.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/src/com/mygdx/game/PantallaPartida.java" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.mygdx.game;&#10;&#10;import com.badlogic.gdx.Screen;&#10;import com.badlogic.gdx.Gdx;&#10;import com.badlogic.gdx.graphics.GL20;&#10;&#10;public class PantallaPartida implements Screen {&#10;    private final MainGame game;&#10;&#10;    public PantallaPartida(MainGame game) {&#10;        this.game = game;&#10;        // ...aquí puedes inicializar recursos de la partida...&#10;    }&#10;&#10;    @Override&#10;    public void show() {&#10;        // ...código de inicialización de la pantalla de partida...&#10;    }&#10;&#10;    @Override&#10;    public void render(float delta) {&#10;        Gdx.gl.glClearColor(0.1f, 0.1f, 0.1f, 1);&#10;        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);&#10;        // ...lógica y renderizado de la partida...&#10;    }&#10;&#10;    @Override&#10;    public void resize(int width, int height) {&#10;        // ...si necesitas ajustar la vista...&#10;    }&#10;&#10;    @Override&#10;    public void pause() {}&#10;&#10;    @Override&#10;    public void resume() {}&#10;&#10;    @Override&#10;    public void hide() {&#10;        // ...libera recursos si es necesario...&#10;    }&#10;&#10;    @Override&#10;    public void dispose() {&#10;        // ...libera recursos de la partida...&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/src/main/java/com.Envit.Juego/pantallas/PantallaPartida.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/src/main/java/com.Envit.Juego/pantallas/PantallaPartida.java" />
              <option name="originalContent" value="package com.Envit.Juego.pantallas;&#10;&#10;import com.Envit.Juego.Principal;&#10;import com.badlogic.gdx.Gdx;&#10;import com.badlogic.gdx.Screen;&#10;import com.badlogic.gdx.Input;&#10;import com.badlogic.gdx.graphics.Color;&#10;import com.badlogic.gdx.graphics.GL20;&#10;import com.badlogic.gdx.graphics.Texture;&#10;import com.badlogic.gdx.graphics.g2d.SpriteBatch;&#10;import com.badlogic.gdx.graphics.g2d.TextureRegion;&#10;import com.badlogic.gdx.math.MathUtils;&#10;import com.badlogic.gdx.utils.viewport.FitViewport;&#10;import com.badlogic.gdx.utils.viewport.Viewport;&#10;import com.badlogic.gdx.graphics.glutils.ShapeRenderer;&#10;import com.badlogic.gdx.math.Vector2;&#10;import com.badlogic.gdx.audio.Sound;&#10;import com.badlogic.gdx.math.Rectangle;&#10;import com.badlogic.gdx.graphics.g2d.BitmapFont;&#10;&#10;public class PantallaPartida implements Screen {&#10;    private final Principal game;&#10;    private SpriteBatch batch;&#10;    private Texture barajaTexture;&#10;    private Texture fondoPartida;&#10;    private TextureRegion[][] cartas; // [fila][columna]&#10;    private int[][] cartasMostradas; // [3][2] -&gt; fila, columna&#10;    private Partida partida;&#10;    // Viewport para mantener relación de aspecto&#10;    private static final float VIRTUAL_WIDTH = 1000;&#10;    private static final float VIRTUAL_HEIGHT = 625;&#10;    private Viewport viewport;&#10;    private ShapeRenderer shapeRenderer;&#10;&#10;    // Gestión de estados&#10;    private enum EstadoJuego { JUGANDO, PAUSADO, FINALIZADO }&#10;    private EstadoJuego estado = EstadoJuego.JUGANDO;&#10;&#10;    // Ahora 6 cartas&#10;    private static final int NUM_CARTAS = 6;&#10;    private TextureRegion[] cartasRecortadas = new TextureRegion[NUM_CARTAS];&#10;    // Posiciones y arrastre&#10;    private Vector2[] cartaPos = new Vector2[NUM_CARTAS];&#10;    private boolean[] cartaArrastrando = new boolean[NUM_CARTAS];&#10;    private Vector2 arrastreOffset = new Vector2();&#10;    private int cartaSeleccionada = -1;&#10;&#10;    // Sonido al clickear carta&#10;    private Sound cartaClickSound;&#10;&#10;    // Posiciones objetivo para animación&#10;    private Vector2[] cartaPosObjetivo = new Vector2[NUM_CARTAS];&#10;&#10;    // Físicas para cartas&#10;    private Vector2[] cartaVel = new Vector2[NUM_CARTAS];&#10;    private Vector2[] cartaAcel = new Vector2[NUM_CARTAS];&#10;    private static final float CARTA_REPELENCIA = 42000f; // fuerza de repulsión entre cartas&#10;    private static final float CARTA_DISTANCIA_MIN = 100f; // distancia mínima antes de repeler&#10;&#10;    // Marco de carta&#10;    private Texture marcoCartaTexture;&#10;&#10;    // Casilla para jugar cartas&#10;    private Rectangle casillaCartas;&#10;&#10;    // Estado de cartas jugadas&#10;    private boolean[] cartaJugada = new boolean[NUM_CARTAS];&#10;&#10;    // Textura para la casilla&#10;    private Texture casillaTexture;&#10;&#10;    // Para turnos y apilado&#10;    private int turno = 0; // 0 = abajo, 1 = arriba&#10;    private int[] cartasJugadasOrden = new int[NUM_CARTAS]; // guarda el orden de jugada&#10;    private int cantidadJugadas = 0;&#10;&#10;    // Fuente para nombres de cartas&#10;    private BitmapFont font = new BitmapFont();&#10;    private int cartaHover = -1;&#10;&#10;    public PantallaPartida(Principal game) {&#10;&#10;        this.game = game;&#10;        this.partida = new Partida();&#10;&#10;&#10;    }&#10;&#10;    @Override&#10;    public void show() {&#10;        batch = new SpriteBatch();&#10;        shapeRenderer = new ShapeRenderer();&#10;        fondoPartida= new Texture(Gdx.files.internal(&quot;fondos/fondoPartida.png&quot;));&#10;        barajaTexture = new Texture(Gdx.files.internal(&quot;sprites/baraja2.png&quot;));&#10;        viewport = new FitViewport(VIRTUAL_WIDTH, VIRTUAL_HEIGHT);&#10;        recortarSeisCartas();&#10;        inicializarPosicionesCartas();&#10;        cartaClickSound = Gdx.audio.newSound(Gdx.files.internal(&quot;sounds/carta.wav&quot;));&#10;        marcoCartaTexture = new Texture(Gdx.files.internal(&quot;sprites/marcoCARTA.png&quot;));&#10;        casillaTexture = new Texture(Gdx.files.internal(&quot;sprites/casilla.png&quot;));&#10;        // Casilla centrada en el medio&#10;        float casillaW = 120, casillaH = 170;&#10;        casillaCartas = new Rectangle(&#10;            VIRTUAL_WIDTH/2f - casillaW/2,&#10;            VIRTUAL_HEIGHT/2f - casillaH/2,&#10;            casillaW,&#10;            casillaH&#10;        );&#10;        for (int i = 0; i &lt; NUM_CARTAS; i++) cartaJugada[i] = false;&#10;    }&#10;&#10;    // Recorta 6 cartas únicas (ajustado para 10 columnas: 2,3,4,5,6,7,10,Caballo,Rey,Ancho)&#10;    private void recortarSeisCartas() {&#10;        int cartaW = barajaTexture.getWidth() / 10;&#10;        int cartaH = barajaTexture.getHeight() / 4;&#10;        boolean[][] usadas = new boolean[4][10];&#10;        for (int i = 0; i &lt; NUM_CARTAS; i++) {&#10;            TextureRegion region = null;&#10;            int fila, col;&#10;            do {&#10;                fila = MathUtils.random(0, 3);&#10;                col = MathUtils.random(0, 9);&#10;            } while (usadas[fila][col]);&#10;            usadas[fila][col] = true;&#10;            region = new TextureRegion(barajaTexture, col * cartaW, fila * cartaH, cartaW, cartaH);&#10;            cartasRecortadas[i] = region;&#10;        }&#10;    }&#10;&#10;    // 3 cartas abajo, 3 arriba&#10;    private void inicializarPosicionesCartas() {&#10;        int cartaW = 100, cartaH = 150, espacio = 20;&#10;        int totalW = 3 * cartaW + 2 * espacio;&#10;        int startX = (int)((VIRTUAL_WIDTH - totalW) / 2);&#10;&#10;        int yAbajo = 40;&#10;        int yArriba = (int)(VIRTUAL_HEIGHT - cartaH - 40);&#10;&#10;        for (int i = 0; i &lt; 3; i++) {&#10;            cartaPos[i] = new Vector2(startX + i * (cartaW + espacio), yAbajo);&#10;            cartaVel[i] = new Vector2(0, 0);&#10;            cartaAcel[i] = new Vector2(0, 0);&#10;            cartaArrastrando[i] = false;&#10;        }&#10;        for (int i = 3; i &lt; NUM_CARTAS; i++) {&#10;            cartaPos[i] = new Vector2(startX + (i-3) * (cartaW + espacio), yArriba);&#10;            cartaVel[i] = new Vector2(0, 0);&#10;            cartaAcel[i] = new Vector2(0, 0);&#10;            cartaArrastrando[i] = false;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void render(float delta) {&#10;        viewport.apply();&#10;        batch.setProjectionMatrix(viewport.getCamera().combined);&#10;        shapeRenderer.setProjectionMatrix(viewport.getCamera().combined);&#10;&#10;        Gdx.gl.glClearColor(0, 0.1f, 0, 1);&#10;        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);&#10;&#10;        manejarInput();&#10;&#10;        // Físicas entre cartas (solo si no están jugadas)&#10;        for (int i = 0; i &lt; NUM_CARTAS; i++) {&#10;            if (cartaArrastrando[i] || cartaJugada[i]) continue;&#10;            for (int j = 0; j &lt; NUM_CARTAS; j++) {&#10;                if (i == j || cartaArrastrando[j] || cartaJugada[j]) continue;&#10;                float cartaW = 100, cartaH = 150;&#10;                Vector2 centroA = new Vector2(cartaPos[i].x + cartaW/2, cartaPos[i].y + cartaH/2);&#10;                Vector2 centroB = new Vector2(cartaPos[j].x + cartaW/2, cartaPos[j].y + cartaH/2);&#10;                float dist = centroA.dst(centroB);&#10;                if (dist &lt; CARTA_DISTANCIA_MIN) {&#10;                    Vector2 dir = new Vector2(centroA.x - centroB.x, centroA.y - centroB.y);&#10;                    if (dir.len() == 0) dir.set(MathUtils.random(-1f,1f), MathUtils.random(-1f,1f));&#10;                    dir.nor();&#10;                    float fuerza = (CARTA_DISTANCIA_MIN - dist) / CARTA_DISTANCIA_MIN * CARTA_REPELENCIA * delta;&#10;                    cartaPos[i].add(dir.scl(fuerza * 0.01f));&#10;                }&#10;            }&#10;        }&#10;&#10;        // Dibuja fondo de partida y casilla&#10;        batch.begin();&#10;        batch.draw(fondoPartida, 0, 0, VIRTUAL_WIDTH, VIRTUAL_HEIGHT);&#10;        batch.end();&#10;&#10;        // Fondo gris semitransparente de la casilla&#10;        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);&#10;        shapeRenderer.setColor(0.3f, 0.3f, 0.3f, 0.45f);&#10;        dibujarRectRedondeado(shapeRenderer, casillaCartas.x, casillaCartas.y, casillaCartas.width, casillaCartas.height, 18f);&#10;        shapeRenderer.end();&#10;&#10;        // Dibuja la textura de la casilla&#10;        batch.begin();&#10;        if (casillaTexture != null) {&#10;            batch.draw(casillaTexture, casillaCartas.x, casillaCartas.y, casillaCartas.width, casillaCartas.height);&#10;        }&#10;        batch.end();&#10;&#10;        // Dibuja cartas jugadas en la casilla (apiladas en orden de jugada)&#10;        batch.begin();&#10;        float cartaW = 100, cartaH = 150;&#10;        for (int i = 0; i &lt; cantidadJugadas; i++) {&#10;            int idx = cartasJugadasOrden[i];&#10;            float cx = casillaCartas.x + (casillaCartas.width - cartaW)/2;&#10;            float cy = casillaCartas.y + (casillaCartas.height - cartaH)/2 + i * 10; // apila con desplazamiento vertical&#10;            batch.end();&#10;            shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);&#10;            shapeRenderer.setColor(1, 1, 1, 1);&#10;            dibujarRectRedondeado(shapeRenderer, cx, cy, cartaW, cartaH, 14f);&#10;            shapeRenderer.end();&#10;            batch.begin();&#10;            batch.draw(cartasRecortadas[idx], cx, cy, cartaW, cartaH);&#10;            if (marcoCartaTexture != null) {&#10;                batch.draw(marcoCartaTexture, cx, cy, cartaW, cartaH);&#10;            }&#10;        }&#10;        batch.end();&#10;&#10;        // Dibuja cartas no jugadas (por arriba de la casilla)&#10;        for (int k = 0; k &lt; NUM_CARTAS; k++) {&#10;            if (cartaJugada[k]) continue;&#10;            shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);&#10;            shapeRenderer.setColor(1, 1, 1, 1);&#10;            dibujarRectRedondeado(shapeRenderer, cartaPos[k].x, cartaPos[k].y, cartaW, cartaH, 14f);&#10;            shapeRenderer.end();&#10;&#10;            batch.begin();&#10;            if (cartasRecortadas[k] != null &amp;&amp; cartasRecortadas[k].getRegionWidth() &gt; 0 &amp;&amp; cartasRecortadas[k].getRegionHeight() &gt; 0) {&#10;                batch.draw(cartasRecortadas[k], cartaPos[k].x, cartaPos[k].y, cartaW, cartaH);&#10;            }&#10;            if (marcoCartaTexture != null) {&#10;                batch.draw(marcoCartaTexture, cartaPos[k].x, cartaPos[k].y, cartaW, cartaH);&#10;            }&#10;            batch.end();&#10;        }&#10;&#10;        // Detecta hover&#10;        Vector2 mouse = viewport.unproject(new Vector2(Gdx.input.getX(), Gdx.input.getY()));&#10;        cartaHover = -1;&#10;        cartaW = 100;&#10;        cartaH = 150;&#10;        for (int k = 0; k &lt; NUM_CARTAS; k++) {&#10;            if (cartaJugada[k]) continue;&#10;            if (mouse.x &gt;= cartaPos[k].x &amp;&amp; mouse.x &lt;= cartaPos[k].x + cartaW &amp;&amp;&#10;                mouse.y &gt;= cartaPos[k].y &amp;&amp; mouse.y &lt;= cartaPos[k].y + cartaH) {&#10;                cartaHover = k;&#10;                break;&#10;            }&#10;        }&#10;&#10;        // Dibuja el nombre de la carta en hover&#10;        if (cartaHover != -1) {&#10;            batch.begin();&#10;            String nombre = getNombreCarta(cartaHover);&#10;            font.setColor(Color.BLACK);&#10;            font.getData().setScale(1.2f);&#10;            float x = cartaPos[cartaHover].x + cartaW/2 - font.getRegion().getRegionWidth()/4;&#10;            float y = cartaPos[cartaHover].y + cartaH + 25;&#10;            font.draw(batch, nombre, x, y);&#10;            batch.end();&#10;        }&#10;&#10;        // Overlay de pausa&#10;        batch.begin();&#10;        if (estado == EstadoJuego.PAUSADO) {&#10;            batch.setColor(0, 0, 0, 0.5f);&#10;            batch.draw(getWhitePixel(), 0, 0, VIRTUAL_WIDTH, VIRTUAL_HEIGHT);&#10;            batch.setColor(Color.WHITE);&#10;        }&#10;        batch.end();&#10;    }&#10;&#10;    // Devuelve el nombre de la carta según su fila y columna (nuevo orden)&#10;    private String getNombreCarta(int idx) {&#10;        int cartaW = barajaTexture.getWidth() / 10;&#10;        int cartaH = barajaTexture.getHeight() / 4;&#10;        TextureRegion region = cartasRecortadas[idx];&#10;        int col = region.getRegionX() / cartaW;&#10;        int fila = region.getRegionY() / cartaH;&#10;        String palo = &quot;&quot;;&#10;        switch (fila) {&#10;            case 0: palo = &quot;Copas&quot;; break;&#10;            case 1: palo = &quot;Basto&quot;; break;&#10;            case 2: palo = &quot;Oro&quot;; break;&#10;            case 3: palo = &quot;Espadas&quot;; break;&#10;        }&#10;        String[] valores = {&quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;10&quot;, &quot;Caballo&quot;, &quot;Rey&quot;, &quot;Ancho&quot;};&#10;        String valor = (col &gt;= 0 &amp;&amp; col &lt; valores.length) ? valores[col] : &quot;?&quot;;&#10;        return valor + &quot; de &quot; + palo;&#10;    }&#10;&#10;    // Dibuja un rectángulo con esquinas redondeadas&#10;    private void dibujarRectRedondeado(ShapeRenderer sr, float x, float y, float w, float h, float r) {&#10;        // Centro&#10;        sr.rect(x + r, y + r, w - 2 * r, h - 2 * r);&#10;        // Lados&#10;        sr.rect(x + r, y, w - 2 * r, r); // abajo&#10;        sr.rect(x + r, y + h - r, w - 2 * r, r); // arriba&#10;        sr.rect(x, y + r, r, h - 2 * r); // izq&#10;        sr.rect(x + w - r, y + r, r, h - 2 * r); // der&#10;        // Esquinas&#10;        sr.arc(x + r, y + r, r, 180, 90); // abajo izq&#10;        sr.arc(x + w - r, y + r, r, 270, 90); // abajo der&#10;        sr.arc(x + w - r, y + h - r, r, 0, 90); // arriba der&#10;        sr.arc(x + r, y + h - r, r, 90, 90); // arriba izq&#10;    }&#10;&#10;    private void manejarInput() {&#10;        if (Gdx.input.isKeyJustPressed(Input.Keys.ESCAPE)) {&#10;            if (estado == EstadoJuego.JUGANDO) {&#10;                estado = EstadoJuego.PAUSADO;&#10;            } else if (estado == EstadoJuego.PAUSADO) {&#10;                estado = EstadoJuego.JUGANDO;&#10;            }&#10;        }&#10;        if (estado == EstadoJuego.PAUSADO &amp;&amp; Gdx.input.isKeyJustPressed(Input.Keys.M)) {&#10;            game.setScreen(new PantallaMenu(game));&#10;        }&#10;&#10;        Vector2 mouse = viewport.unproject(new Vector2(Gdx.input.getX(), Gdx.input.getY()));&#10;        if (Gdx.input.justTouched()) {&#10;            for (int i = 0; i &lt; NUM_CARTAS; i++) {&#10;                if (cartaJugada[i]) continue;&#10;                int cartaW = 100, cartaH = 150;&#10;                if (mouse.x &gt;= cartaPos[i].x &amp;&amp; mouse.x &lt;= cartaPos[i].x + cartaW &amp;&amp;&#10;                    mouse.y &gt;= cartaPos[i].y &amp;&amp; mouse.y &lt;= cartaPos[i].y + cartaH) {&#10;                    cartaArrastrando[i] = true;&#10;                    cartaSeleccionada = i;&#10;                    arrastreOffset.set(mouse.x - cartaPos[i].x, mouse.y - cartaPos[i].y);&#10;                    if (cartaClickSound != null) cartaClickSound.play(0.7f);&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;        if (Gdx.input.isTouched() &amp;&amp; cartaSeleccionada != -1) {&#10;            if (!cartaJugada[cartaSeleccionada]) {&#10;                cartaPos[cartaSeleccionada].set(mouse.x - arrastreOffset.x, mouse.y - arrastreOffset.y);&#10;            }&#10;        }&#10;        if (!Gdx.input.isTouched()) {&#10;            if (cartaSeleccionada != -1) {&#10;                int cartaW = 100, cartaH = 150;&#10;                Rectangle cartaRect = new Rectangle(&#10;                    cartaPos[cartaSeleccionada].x, cartaPos[cartaSeleccionada].y, cartaW, cartaH&#10;                );&#10;                // Solo puede jugar si es su turno&#10;                boolean puedeJugar = false;&#10;                if (turno == 0 &amp;&amp; cartaSeleccionada &lt; 3) puedeJugar = true;&#10;                if (turno == 1 &amp;&amp; cartaSeleccionada &gt;= 3) puedeJugar = true;&#10;&#10;                if (puedeJugar &amp;&amp; cartaRect.overlaps(casillaCartas)) {&#10;                    cartaJugada[cartaSeleccionada] = true;&#10;                    // Apila la carta en la casilla, en orden de jugada&#10;                    cartasJugadasOrden[cantidadJugadas] = cartaSeleccionada;&#10;                    cantidadJugadas++;&#10;                    cartaPos[cartaSeleccionada].set(&#10;                        casillaCartas.x + (casillaCartas.width - cartaW)/2,&#10;                        casillaCartas.y + (casillaCartas.height - cartaH)/2 + (cantidadJugadas-1)*10 // apilado&#10;                    );&#10;                    // Cambia turno&#10;                    turno = 1 - turno;&#10;                }&#10;                cartaArrastrando[cartaSeleccionada] = false;&#10;                cartaSeleccionada = -1;&#10;            }&#10;        }&#10;    }&#10;&#10;    // Evita que la carta seleccionada se superponga con las otras&#10;    private void ajustarPosicionCarta(int idx) {&#10;        int cartaW = 100, cartaH = 150;&#10;        for (int i = 0; i &lt; NUM_CARTAS; i++) {&#10;            if (i == idx) continue;&#10;            if (rectsSolapan(cartaPos[idx], cartaPos[i], cartaW, cartaH)) {&#10;                // Mueve la carta seleccionada a la posición más cercana libre (a la derecha)&#10;                float espacio = 20;&#10;                float nuevaX = cartaPos[i].x + cartaW + espacio;&#10;                if (nuevaX + cartaW &gt; VIRTUAL_WIDTH) {&#10;                    // Si se sale de pantalla, la mueve a la izquierda&#10;                    nuevaX = cartaPos[i].x - cartaW - espacio;&#10;                    if (nuevaX &lt; 0) nuevaX = 0;&#10;                }&#10;                cartaPos[idx].x = nuevaX;&#10;                // Opcional: también puedes ajustar Y si quieres&#10;            }&#10;        }&#10;    }&#10;&#10;    private boolean rectsSolapan(Vector2 a, Vector2 b, int w, int h) {&#10;        return a.x &lt; b.x + w &amp;&amp; a.x + w &gt; b.x &amp;&amp; a.y &lt; b.y + h &amp;&amp; a.y + h &gt; b.y;&#10;    }&#10;&#10;    // Textura 1x1 blanca para overlays&#10;    private Texture whitePixel;&#10;    private Texture getWhitePixel() {&#10;        if (whitePixel == null) {&#10;            com.badlogic.gdx.graphics.Pixmap pixmap = new com.badlogic.gdx.graphics.Pixmap(1,1, com.badlogic.gdx.graphics.Pixmap.Format.RGBA8888);&#10;            pixmap.setColor(Color.WHITE);&#10;            pixmap.fill();&#10;            whitePixel = new Texture(pixmap);&#10;            pixmap.dispose();&#10;        }&#10;        return whitePixel;&#10;    }&#10;&#10;    // Ranking de Truco argentino por [fila][columna] de la baraja (nuevo orden)&#10;    // fila: 0=Copas, 1=Basto, 2=Oro, 3=Espadas&#10;    // columna: 0=2, 1=3, 2=4, 3=5, 4=6, 5=7, 6=10, 7=Caballo, 8=Rey, 9=Ancho&#10;    private int getRankingTruco(int fila, int col) {&#10;        // Ancho de Espadas&#10;        if (fila == 3 &amp;&amp; col == 9) return 1;&#10;        // Ancho de Basto&#10;        if (fila == 1 &amp;&amp; col == 9) return 2;&#10;        // 7 de Espadas&#10;        if (fila == 3 &amp;&amp; col == 5) return 3;&#10;        // 7 de Oro&#10;        if (fila == 2 &amp;&amp; col == 5) return 4;&#10;        // 3&#10;        if (col == 1) return 5;&#10;        // 2&#10;        if (col == 0) return 6;&#10;        // Ancho de Copas/Oro&#10;        if ((fila == 0 || fila == 2) &amp;&amp; col == 9) return 7;&#10;        // Rey&#10;        if (col == 8) return 8;&#10;        // Caballo&#10;        if (col == 7) return 9;&#10;        // 10&#10;        if (col == 6) return 10;&#10;        // 7 de Basto/Copas&#10;        if ((fila == 1 || fila == 0) &amp;&amp; col == 5) return 11;&#10;        // 6&#10;        if (col == 4) return 12;&#10;        // 5&#10;        if (col == 3) return 13;&#10;        // 4&#10;        if (col == 2) return 14;&#10;        return 15; // carta más baja&#10;    }&#10;&#10;    @Override&#10;    public void resize(int width, int height) {&#10;        if (viewport != null) {&#10;            viewport.update(width, height, true);&#10;        }&#10;    }&#10;&#10;&#10;    @Override&#10;    public void pause() {}&#10;&#10;    @Override&#10;    public void resume() {}&#10;&#10;    @Override&#10;    public void hide() {}&#10;&#10;    @Override&#10;    public void dispose() {&#10;        batch.dispose();&#10;        shapeRenderer.dispose();&#10;        barajaTexture.dispose();&#10;        if (whitePixel != null) whitePixel.dispose();&#10;        if(fondoPartida != null) fondoPartida.dispose();&#10;        if (cartaClickSound != null) cartaClickSound.dispose();&#10;        if (marcoCartaTexture != null) marcoCartaTexture.dispose();&#10;        if (casillaTexture != null) casillaTexture.dispose();&#10;        font.dispose();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.Envit.Juego.pantallas;&#10;&#10;import com.Envit.Juego.Principal;&#10;import com.badlogic.gdx.Gdx;&#10;import com.badlogic.gdx.Screen;&#10;import com.badlogic.gdx.Input;&#10;import com.badlogic.gdx.graphics.Color;&#10;import com.badlogic.gdx.graphics.GL20;&#10;import com.badlogic.gdx.graphics.Texture;&#10;import com.badlogic.gdx.graphics.g2d.SpriteBatch;&#10;import com.badlogic.gdx.graphics.g2d.TextureRegion;&#10;import com.badlogic.gdx.math.MathUtils;&#10;import com.badlogic.gdx.utils.viewport.FitViewport;&#10;import com.badlogic.gdx.utils.viewport.Viewport;&#10;import com.badlogic.gdx.graphics.glutils.ShapeRenderer;&#10;import com.badlogic.gdx.math.Vector2;&#10;import com.badlogic.gdx.audio.Sound;&#10;import com.badlogic.gdx.math.Rectangle;&#10;import com.badlogic.gdx.graphics.g2d.BitmapFont;&#10;import com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator;&#10;&#10;public class PantallaPartida implements Screen {&#10;    private final Principal game;&#10;    private SpriteBatch batch;&#10;    private Texture barajaTexture;&#10;    private Texture fondoPartida;&#10;    private TextureRegion[][] cartas; // [fila][columna]&#10;    private int[][] cartasMostradas; // [3][2] -&gt; fila, columna&#10;    private Partida partida;&#10;    // Viewport para mantener relación de aspecto&#10;    private static final float VIRTUAL_WIDTH = 1000;&#10;    private static final float VIRTUAL_HEIGHT = 625;&#10;    private Viewport viewport;&#10;    private ShapeRenderer shapeRenderer;&#10;&#10;    // Gestión de estados&#10;    private enum EstadoJuego { JUGANDO, PAUSADO, FINALIZADO }&#10;    private EstadoJuego estado = EstadoJuego.JUGANDO;&#10;&#10;    // Ahora 6 cartas&#10;    private static final int NUM_CARTAS = 6;&#10;    private TextureRegion[] cartasRecortadas = new TextureRegion[NUM_CARTAS];&#10;    // Posiciones y arrastre&#10;    private Vector2[] cartaPos = new Vector2[NUM_CARTAS];&#10;    private boolean[] cartaArrastrando = new boolean[NUM_CARTAS];&#10;    private Vector2 arrastreOffset = new Vector2();&#10;    private int cartaSeleccionada = -1;&#10;&#10;    // Sonido al clickear carta&#10;    private Sound cartaClickSound;&#10;&#10;    // Posiciones objetivo para animación&#10;    private Vector2[] cartaPosObjetivo = new Vector2[NUM_CARTAS];&#10;&#10;    // Físicas para cartas&#10;    private Vector2[] cartaVel = new Vector2[NUM_CARTAS];&#10;    private Vector2[] cartaAcel = new Vector2[NUM_CARTAS];&#10;    private static final float CARTA_REPELENCIA = 42000f; // fuerza de repulsión entre cartas&#10;    private static final float CARTA_DISTANCIA_MIN = 100f; // distancia mínima antes de repeler&#10;&#10;    // Marco de carta&#10;    private Texture marcoCartaTexture;&#10;&#10;    // Casilla para jugar cartas&#10;    private Rectangle casillaCartas;&#10;&#10;    // Estado de cartas jugadas&#10;    private boolean[] cartaJugada = new boolean[NUM_CARTAS];&#10;&#10;    // Textura para la casilla&#10;    private Texture casillaTexture;&#10;&#10;    // Para turnos y apilado&#10;    private int turno = 0; // 0 = abajo, 1 = arriba&#10;    private int[] cartasJugadasOrden = new int[NUM_CARTAS]; // guarda el orden de jugada&#10;    private int cantidadJugadas = 0;&#10;&#10;    // Fuente para nombres de cartas&#10;    private BitmapFont font;&#10;    private int cartaHover = -1;&#10;&#10;    public PantallaPartida(Principal game) {&#10;&#10;        this.game = game;&#10;        this.partida = new Partida();&#10;&#10;&#10;    }&#10;&#10;    @Override&#10;    public void show() {&#10;        batch = new SpriteBatch();&#10;        shapeRenderer = new ShapeRenderer();&#10;        fondoPartida= new Texture(Gdx.files.internal(&quot;fondos/fondoPartida.png&quot;));&#10;        barajaTexture = new Texture(Gdx.files.internal(&quot;sprites/baraja2.png&quot;));&#10;        viewport = new FitViewport(VIRTUAL_WIDTH, VIRTUAL_HEIGHT);&#10;        recortarSeisCartas();&#10;        inicializarPosicionesCartas();&#10;        cartaClickSound = Gdx.audio.newSound(Gdx.files.internal(&quot;sounds/carta.wav&quot;));&#10;        marcoCartaTexture = new Texture(Gdx.files.internal(&quot;sprites/marcoCARTA.png&quot;));&#10;        casillaTexture = new Texture(Gdx.files.internal(&quot;sprites/casilla.png&quot;));&#10;        // Usa la misma fuente medieval.ttf que el menú&#10;        FreeTypeFontGenerator generator = new FreeTypeFontGenerator(Gdx.files.internal(&quot;fuentes/medieval.ttf&quot;));&#10;        FreeTypeFontGenerator.FreeTypeFontParameter parameter = new FreeTypeFontGenerator.FreeTypeFontParameter();&#10;        parameter.size = 22;&#10;        parameter.color = Color.BLACK;&#10;        font = generator.generateFont(parameter);&#10;        generator.dispose();&#10;        // Casilla centrada en el medio&#10;        float casillaW = 120, casillaH = 170;&#10;        casillaCartas = new Rectangle(&#10;            VIRTUAL_WIDTH/2f - casillaW/2,&#10;            VIRTUAL_HEIGHT/2f - casillaH/2,&#10;            casillaW,&#10;            casillaH&#10;        );&#10;        for (int i = 0; i &lt; NUM_CARTAS; i++) cartaJugada[i] = false;&#10;    }&#10;&#10;    // Recorta 6 cartas únicas (ajustado para 10 columnas: 2,3,4,5,6,7,10,Caballo,Rey,Ancho)&#10;    private void recortarSeisCartas() {&#10;        int cartaW = barajaTexture.getWidth() / 10;&#10;        int cartaH = barajaTexture.getHeight() / 4;&#10;        boolean[][] usadas = new boolean[4][10];&#10;        for (int i = 0; i &lt; NUM_CARTAS; i++) {&#10;            TextureRegion region = null;&#10;            int fila, col;&#10;            do {&#10;                fila = MathUtils.random(0, 3);&#10;                col = MathUtils.random(0, 9);&#10;            } while (usadas[fila][col]);&#10;            usadas[fila][col] = true;&#10;            region = new TextureRegion(barajaTexture, col * cartaW, fila * cartaH, cartaW, cartaH);&#10;            cartasRecortadas[i] = region;&#10;        }&#10;    }&#10;&#10;    // 3 cartas abajo, 3 arriba&#10;    private void inicializarPosicionesCartas() {&#10;        int cartaW = 100, cartaH = 150, espacio = 20;&#10;        int totalW = 3 * cartaW + 2 * espacio;&#10;        int startX = (int)((VIRTUAL_WIDTH - totalW) / 2);&#10;&#10;        int yAbajo = 40;&#10;        int yArriba = (int)(VIRTUAL_HEIGHT - cartaH - 40);&#10;&#10;        for (int i = 0; i &lt; 3; i++) {&#10;            cartaPos[i] = new Vector2(startX + i * (cartaW + espacio), yAbajo);&#10;            cartaVel[i] = new Vector2(0, 0);&#10;            cartaAcel[i] = new Vector2(0, 0);&#10;            cartaArrastrando[i] = false;&#10;        }&#10;        for (int i = 3; i &lt; NUM_CARTAS; i++) {&#10;            cartaPos[i] = new Vector2(startX + (i-3) * (cartaW + espacio), yArriba);&#10;            cartaVel[i] = new Vector2(0, 0);&#10;            cartaAcel[i] = new Vector2(0, 0);&#10;            cartaArrastrando[i] = false;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void render(float delta) {&#10;        viewport.apply();&#10;        batch.setProjectionMatrix(viewport.getCamera().combined);&#10;        shapeRenderer.setProjectionMatrix(viewport.getCamera().combined);&#10;&#10;        Gdx.gl.glClearColor(0, 0.1f, 0, 1);&#10;        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);&#10;&#10;        manejarInput();&#10;&#10;        // Físicas entre cartas (solo si no están jugadas)&#10;        for (int i = 0; i &lt; NUM_CARTAS; i++) {&#10;            if (cartaArrastrando[i] || cartaJugada[i]) continue;&#10;            for (int j = 0; j &lt; NUM_CARTAS; j++) {&#10;                if (i == j || cartaArrastrando[j] || cartaJugada[j]) continue;&#10;                float cartaW = 100, cartaH = 150;&#10;                Vector2 centroA = new Vector2(cartaPos[i].x + cartaW/2, cartaPos[i].y + cartaH/2);&#10;                Vector2 centroB = new Vector2(cartaPos[j].x + cartaW/2, cartaPos[j].y + cartaH/2);&#10;                float dist = centroA.dst(centroB);&#10;                if (dist &lt; CARTA_DISTANCIA_MIN) {&#10;                    Vector2 dir = new Vector2(centroA.x - centroB.x, centroA.y - centroB.y);&#10;                    if (dir.len() == 0) dir.set(MathUtils.random(-1f,1f), MathUtils.random(-1f,1f));&#10;                    dir.nor();&#10;                    float fuerza = (CARTA_DISTANCIA_MIN - dist) / CARTA_DISTANCIA_MIN * CARTA_REPELENCIA * delta;&#10;                    cartaPos[i].add(dir.scl(fuerza * 0.01f));&#10;                }&#10;            }&#10;        }&#10;&#10;        // Dibuja fondo de partida y casilla&#10;        batch.begin();&#10;        batch.draw(fondoPartida, 0, 0, VIRTUAL_WIDTH, VIRTUAL_HEIGHT);&#10;        batch.end();&#10;&#10;        // Fondo gris semitransparente de la casilla&#10;        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);&#10;        shapeRenderer.setColor(0.3f, 0.3f, 0.3f, 0.45f);&#10;        dibujarRectRedondeado(shapeRenderer, casillaCartas.x, casillaCartas.y, casillaCartas.width, casillaCartas.height, 18f);&#10;        shapeRenderer.end();&#10;&#10;        // Dibuja la textura de la casilla&#10;        batch.begin();&#10;        if (casillaTexture != null) {&#10;            batch.draw(casillaTexture, casillaCartas.x, casillaCartas.y, casillaCartas.width, casillaCartas.height);&#10;        }&#10;        batch.end();&#10;&#10;        // Dibuja cartas jugadas en la casilla (apiladas en orden de jugada)&#10;        batch.begin();&#10;        float cartaW = 100, cartaH = 150;&#10;        for (int i = 0; i &lt; cantidadJugadas; i++) {&#10;            int idx = cartasJugadasOrden[i];&#10;            float cx = casillaCartas.x + (casillaCartas.width - cartaW)/2;&#10;            float cy = casillaCartas.y + (casillaCartas.height - cartaH)/2 + i * 10; // apila con desplazamiento vertical&#10;            batch.end();&#10;            shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);&#10;            shapeRenderer.setColor(1, 1, 1, 1);&#10;            dibujarRectRedondeado(shapeRenderer, cx, cy, cartaW, cartaH, 14f);&#10;            shapeRenderer.end();&#10;            batch.begin();&#10;            batch.draw(cartasRecortadas[idx], cx, cy, cartaW, cartaH);&#10;            if (marcoCartaTexture != null) {&#10;                batch.draw(marcoCartaTexture, cx, cy, cartaW, cartaH);&#10;            }&#10;        }&#10;        batch.end();&#10;&#10;        // Dibuja cartas no jugadas (por arriba de la casilla)&#10;        for (int k = 0; k &lt; NUM_CARTAS; k++) {&#10;            if (cartaJugada[k]) continue;&#10;            shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);&#10;            shapeRenderer.setColor(1, 1, 1, 1);&#10;            dibujarRectRedondeado(shapeRenderer, cartaPos[k].x, cartaPos[k].y, cartaW, cartaH, 14f);&#10;            shapeRenderer.end();&#10;&#10;            batch.begin();&#10;            if (cartasRecortadas[k] != null &amp;&amp; cartasRecortadas[k].getRegionWidth() &gt; 0 &amp;&amp; cartasRecortadas[k].getRegionHeight() &gt; 0) {&#10;                batch.draw(cartasRecortadas[k], cartaPos[k].x, cartaPos[k].y, cartaW, cartaH);&#10;            }&#10;            if (marcoCartaTexture != null) {&#10;                batch.draw(marcoCartaTexture, cartaPos[k].x, cartaPos[k].y, cartaW, cartaH);&#10;            }&#10;            batch.end();&#10;        }&#10;&#10;        // Detecta hover&#10;        Vector2 mouse = viewport.unproject(new Vector2(Gdx.input.getX(), Gdx.input.getY()));&#10;        cartaHover = -1;&#10;        cartaW = 100;&#10;        cartaH = 150;&#10;        for (int k = 0; k &lt; NUM_CARTAS; k++) {&#10;            if (cartaJugada[k]) continue;&#10;            if (mouse.x &gt;= cartaPos[k].x &amp;&amp; mouse.x &lt;= cartaPos[k].x + cartaW &amp;&amp;&#10;                mouse.y &gt;= cartaPos[k].y &amp;&amp; mouse.y &lt;= cartaPos[k].y + cartaH) {&#10;                cartaHover = k;&#10;                break;&#10;            }&#10;        }&#10;&#10;        // Dibuja el nombre de la carta en hover&#10;        if (cartaHover != -1) {&#10;            batch.begin();&#10;            String nombre = getNombreCarta(cartaHover);&#10;            font.setColor(Color.BLACK);&#10;            font.getData().setScale(1.2f);&#10;            float x = cartaPos[cartaHover].x + cartaW/2 - font.getRegion().getRegionWidth()/4;&#10;            float y = cartaPos[cartaHover].y + cartaH + 25;&#10;            font.draw(batch, nombre, x, y);&#10;            batch.end();&#10;        }&#10;&#10;        // Dibuja el nombre de cada carta centrado sobre la carta (no jugadas)&#10;        for (int k = 0; k &lt; NUM_CARTAS; k++) {&#10;            if (cartaJugada[k]) continue;&#10;            batch.begin();&#10;            String nombre = getNombreCarta(k);&#10;            float cartaW = 100, cartaH = 150;&#10;            float textX = cartaPos[k].x + cartaW / 2;&#10;            float textY = cartaPos[k].y + cartaH / 2 + 8;&#10;            font.draw(batch, nombre, textX, textY, 0, nombre.length(), 0, 1, true);&#10;            batch.end();&#10;        }&#10;&#10;        // Overlay de pausa&#10;        batch.begin();&#10;        if (estado == EstadoJuego.PAUSADO) {&#10;            batch.setColor(0, 0, 0, 0.5f);&#10;            batch.draw(getWhitePixel(), 0, 0, VIRTUAL_WIDTH, VIRTUAL_HEIGHT);&#10;            batch.setColor(Color.WHITE);&#10;        }&#10;        batch.end();&#10;    }&#10;&#10;    // Devuelve el nombre de la carta según su fila y columna (nuevo orden)&#10;    private String getNombreCarta(int idx) {&#10;        int cartaW = barajaTexture.getWidth() / 10;&#10;        int cartaH = barajaTexture.getHeight() / 4;&#10;        TextureRegion region = cartasRecortadas[idx];&#10;        int col = region.getRegionX() / cartaW;&#10;        int fila = region.getRegionY() / cartaH;&#10;        String palo = &quot;&quot;;&#10;        switch (fila) {&#10;            case 0: palo = &quot;Copas&quot;; break;&#10;            case 1: palo = &quot;Basto&quot;; break;&#10;            case 2: palo = &quot;Oro&quot;; break;&#10;            case 3: palo = &quot;Espadas&quot;; break;&#10;        }&#10;        String[] valores = {&quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;10&quot;, &quot;Caballo&quot;, &quot;Rey&quot;, &quot;Ancho&quot;};&#10;        String valor = (col &gt;= 0 &amp;&amp; col &lt; valores.length) ? valores[col] : &quot;?&quot;;&#10;        return valor + &quot; de &quot; + palo;&#10;    }&#10;&#10;    // Dibuja un rectángulo con esquinas redondeadas&#10;    private void dibujarRectRedondeado(ShapeRenderer sr, float x, float y, float w, float h, float r) {&#10;        // Centro&#10;        sr.rect(x + r, y + r, w - 2 * r, h - 2 * r);&#10;        // Lados&#10;        sr.rect(x + r, y, w - 2 * r, r); // abajo&#10;        sr.rect(x + r, y + h - r, w - 2 * r, r); // arriba&#10;        sr.rect(x, y + r, r, h - 2 * r); // izq&#10;        sr.rect(x + w - r, y + r, r, h - 2 * r); // der&#10;        // Esquinas&#10;        sr.arc(x + r, y + r, r, 180, 90); // abajo izq&#10;        sr.arc(x + w - r, y + r, r, 270, 90); // abajo der&#10;        sr.arc(x + w - r, y + h - r, r, 0, 90); // arriba der&#10;        sr.arc(x + r, y + h - r, r, 90, 90); // arriba izq&#10;    }&#10;&#10;    private void manejarInput() {&#10;        if (Gdx.input.isKeyJustPressed(Input.Keys.ESCAPE)) {&#10;            if (estado == EstadoJuego.JUGANDO) {&#10;                estado = EstadoJuego.PAUSADO;&#10;            } else if (estado == EstadoJuego.PAUSADO) {&#10;                estado = EstadoJuego.JUGANDO;&#10;            }&#10;        }&#10;        if (estado == EstadoJuego.PAUSADO &amp;&amp; Gdx.input.isKeyJustPressed(Input.Keys.M)) {&#10;            game.setScreen(new PantallaMenu(game));&#10;        }&#10;&#10;        Vector2 mouse = viewport.unproject(new Vector2(Gdx.input.getX(), Gdx.input.getY()));&#10;        if (Gdx.input.justTouched()) {&#10;            for (int i = 0; i &lt; NUM_CARTAS; i++) {&#10;                if (cartaJugada[i]) continue;&#10;                int cartaW = 100, cartaH = 150;&#10;                if (mouse.x &gt;= cartaPos[i].x &amp;&amp; mouse.x &lt;= cartaPos[i].x + cartaW &amp;&amp;&#10;                    mouse.y &gt;= cartaPos[i].y &amp;&amp; mouse.y &lt;= cartaPos[i].y + cartaH) {&#10;                    cartaArrastrando[i] = true;&#10;                    cartaSeleccionada = i;&#10;                    arrastreOffset.set(mouse.x - cartaPos[i].x, mouse.y - cartaPos[i].y);&#10;                    if (cartaClickSound != null) cartaClickSound.play(0.7f);&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;        if (Gdx.input.isTouched() &amp;&amp; cartaSeleccionada != -1) {&#10;            if (!cartaJugada[cartaSeleccionada]) {&#10;                cartaPos[cartaSeleccionada].set(mouse.x - arrastreOffset.x, mouse.y - arrastreOffset.y);&#10;            }&#10;        }&#10;        if (!Gdx.input.isTouched()) {&#10;            if (cartaSeleccionada != -1) {&#10;                int cartaW = 100, cartaH = 150;&#10;                Rectangle cartaRect = new Rectangle(&#10;                    cartaPos[cartaSeleccionada].x, cartaPos[cartaSeleccionada].y, cartaW, cartaH&#10;                );&#10;                // Solo puede jugar si es su turno&#10;                boolean puedeJugar = false;&#10;                if (turno == 0 &amp;&amp; cartaSeleccionada &lt; 3) puedeJugar = true;&#10;                if (turno == 1 &amp;&amp; cartaSeleccionada &gt;= 3) puedeJugar = true;&#10;&#10;                if (puedeJugar &amp;&amp; cartaRect.overlaps(casillaCartas)) {&#10;                    cartaJugada[cartaSeleccionada] = true;&#10;                    // Apila la carta en la casilla, en orden de jugada&#10;                    cartasJugadasOrden[cantidadJugadas] = cartaSeleccionada;&#10;                    cantidadJugadas++;&#10;                    cartaPos[cartaSeleccionada].set(&#10;                        casillaCartas.x + (casillaCartas.width - cartaW)/2,&#10;                        casillaCartas.y + (casillaCartas.height - cartaH)/2 + (cantidadJugadas-1)*10 // apilado&#10;                    );&#10;                    // Cambia turno&#10;                    turno = 1 - turno;&#10;                }&#10;                cartaArrastrando[cartaSeleccionada] = false;&#10;                cartaSeleccionada = -1;&#10;            }&#10;        }&#10;    }&#10;&#10;    // Evita que la carta seleccionada se superponga con las otras&#10;    private void ajustarPosicionCarta(int idx) {&#10;        int cartaW = 100, cartaH = 150;&#10;        for (int i = 0; i &lt; NUM_CARTAS; i++) {&#10;            if (i == idx) continue;&#10;            if (rectsSolapan(cartaPos[idx], cartaPos[i], cartaW, cartaH)) {&#10;                // Mueve la carta seleccionada a la posición más cercana libre (a la derecha)&#10;                float espacio = 20;&#10;                float nuevaX = cartaPos[i].x + cartaW + espacio;&#10;                if (nuevaX + cartaW &gt; VIRTUAL_WIDTH) {&#10;                    // Si se sale de pantalla, la mueve a la izquierda&#10;                    nuevaX = cartaPos[i].x - cartaW - espacio;&#10;                    if (nuevaX &lt; 0) nuevaX = 0;&#10;                }&#10;                cartaPos[idx].x = nuevaX;&#10;                // Opcional: también puedes ajustar Y si quieres&#10;            }&#10;        }&#10;    }&#10;&#10;    private boolean rectsSolapan(Vector2 a, Vector2 b, int w, int h) {&#10;        return a.x &lt; b.x + w &amp;&amp; a.x + w &gt; b.x &amp;&amp; a.y &lt; b.y + h &amp;&amp; a.y + h &gt; b.y;&#10;    }&#10;&#10;    // Textura 1x1 blanca para overlays&#10;    private Texture whitePixel;&#10;    private Texture getWhitePixel() {&#10;        if (whitePixel == null) {&#10;            com.badlogic.gdx.graphics.Pixmap pixmap = new com.badlogic.gdx.graphics.Pixmap(1,1, com.badlogic.gdx.graphics.Pixmap.Format.RGBA8888);&#10;            pixmap.setColor(Color.WHITE);&#10;            pixmap.fill();&#10;            whitePixel = new Texture(pixmap);&#10;            pixmap.dispose();&#10;        }&#10;        return whitePixel;&#10;    }&#10;&#10;    // Ranking de Truco argentino por [fila][columna] de la baraja (nuevo orden)&#10;    // fila: 0=Copas, 1=Basto, 2=Oro, 3=Espadas&#10;    // columna: 0=2, 1=3, 2=4, 3=5, 4=6, 5=7, 6=10, 7=Caballo, 8=Rey, 9=Ancho&#10;    private int getRankingTruco(int fila, int col) {&#10;        // Ancho de Espadas&#10;        if (fila == 3 &amp;&amp; col == 9) return 1;&#10;        // Ancho de Basto&#10;        if (fila == 1 &amp;&amp; col == 9) return 2;&#10;        // 7 de Espadas&#10;        if (fila == 3 &amp;&amp; col == 5) return 3;&#10;        // 7 de Oro&#10;        if (fila == 2 &amp;&amp; col == 5) return 4;&#10;        // 3&#10;        if (col == 1) return 5;&#10;        // 2&#10;        if (col == 0) return 6;&#10;        // Ancho de Copas/Oro&#10;        if ((fila == 0 || fila == 2) &amp;&amp; col == 9) return 7;&#10;        // Rey&#10;        if (col == 8) return 8;&#10;        // Caballo&#10;        if (col == 7) return 9;&#10;        // 10&#10;        if (col == 6) return 10;&#10;        // 7 de Basto/Copas&#10;        if ((fila == 1 || fila == 0) &amp;&amp; col == 5) return 11;&#10;        // 6&#10;        if (col == 4) return 12;&#10;        // 5&#10;        if (col == 3) return 13;&#10;        // 4&#10;        if (col == 2) return 14;&#10;        return 15; // carta más baja&#10;    }&#10;&#10;    @Override&#10;    public void resize(int width, int height) {&#10;        if (viewport != null) {&#10;            viewport.update(width, height, true);&#10;        }&#10;    }&#10;&#10;&#10;    @Override&#10;    public void pause() {}&#10;&#10;    @Override&#10;    public void resume() {}&#10;&#10;    @Override&#10;    public void hide() {}&#10;&#10;    @Override&#10;    public void dispose() {&#10;        batch.dispose();&#10;        shapeRenderer.dispose();&#10;        barajaTexture.dispose();&#10;        if (whitePixel != null) whitePixel.dispose();&#10;        if(fondoPartida != null) fondoPartida.dispose();&#10;        if (cartaClickSound != null) cartaClickSound.dispose();&#10;        if (marcoCartaTexture != null) marcoCartaTexture.dispose();&#10;        if (casillaTexture != null) casillaTexture.dispose();&#10;        if (font != null) font.dispose();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/src/main/java/com.Envit.Juego/personajes/Jugador.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/src/main/java/com.Envit.Juego/personajes/Jugador.java" />
              <option name="originalContent" value="package com.Envit.Juego.personajes;&#10;&#10;import com.Envit.Juego.elementos.Carta;&#10;&#10; public class Jugador {&#10;&#9;private String nombre;&#10;&#9;private int puntos;&#10;&#9;private Carta mano[] = new Carta[3];&#10;&#9;private int cantCartas = 0;&#10;&#10;&#9;public String getNombre() {&#10;&#9;&#9;return nombre;&#10;&#9;}&#10;&#10;&#9;public Carta[] getMano() {&#10;&#9;&#9;return mano;&#10;&#9;}&#10;&#10;&#9;public int getPuntos() {&#10;&#9;&#9;return puntos;&#10;&#9;}&#10;&#10;&#9;public void agregarCarta(Carta c){&#10;&#9;&#9;this.mano[cantCartas] = c;&#10;&#9;&#9;cantCartas++;&#10;&#9;}&#10;&#10;&#9;public void limpiarMazo(){&#10;&#9;&#9;cantCartas = 0;&#10;&#9;}&#10;}" />
              <option name="updatedContent" value="package com.Envit.Juego.personajes;&#13;&#10;&#13;&#10;import com.Envit.Juego.elementos.Carta;&#13;&#10;&#13;&#10; public class Jugador {&#13;&#10;&#9;private String nombre;&#13;&#10;&#9;private int puntos;&#13;&#10;&#9;private Carta[] mano = new Carta[3];&#13;&#10;&#9;private int cantCartas = 0;&#13;&#10;&#13;&#10;&#9;public String getNombre() {&#13;&#10;&#9;&#9;return nombre;&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;public Carta[] getMano() {&#13;&#10;&#9;&#9;return mano;&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;public int getPuntos() {&#13;&#10;&#9;&#9;return puntos;&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;public void agregarCarta(Carta c){&#13;&#10;&#9;&#9;if (cantCartas &lt; mano.length) {&#13;&#10;&#9;&#9;&#9;this.mano[cantCartas] = c;&#13;&#10;&#9;&#9;&#9;cantCartas++;&#13;&#10;&#9;&#9;}&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;public void limpiarMazo(){&#13;&#10;&#9;&#9;for (int i = 0; i &lt; mano.length; i++) mano[i] = null;&#13;&#10;&#9;&#9;cantCartas = 0;&#13;&#10;&#9;}&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>