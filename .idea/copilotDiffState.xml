<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/core/src/com/mygdx/game/MainGame.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/src/com/mygdx/game/MainGame.java" />
              <option name="updatedContent" value="package com.mygdx.game;&#10;&#10;import com.badlogic.gdx.Game;&#10;&#10;public class MainGame extends Game {&#10;    @Override&#10;    public void create() {&#10;        setScreen(new PantallaMenu(this));&#10;    }&#10;    // ...resto del código...&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/src/com/mygdx/game/PantallaMenu.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/src/com/mygdx/game/PantallaMenu.java" />
              <option name="originalContent" value="package com.mygdx.game;&#10;&#10;import com.badlogic.gdx.Gdx;&#10;import com.badlogic.gdx.Screen;&#10;import com.badlogic.gdx.graphics.GL20;&#10;import com.badlogic.gdx.scenes.scene2d.Stage;&#10;import com.badlogic.gdx.scenes.scene2d.ui.Skin;&#10;import com.badlogic.gdx.scenes.scene2d.ui.TextButton;&#10;import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;&#10;import com.badlogic.gdx.scenes.scene2d.InputEvent;&#10;import com.badlogic.gdx.utils.viewport.ScreenViewport;&#10;&#10;public class PantallaMenu implements Screen {&#10;    private final MainGame game;&#10;    private Stage stage;&#10;    private Skin skin;&#10;&#10;    public PantallaMenu(MainGame game) {&#10;        this.game = game;&#10;    }&#10;&#10;    @Override&#10;    public void show() {&#10;        stage = new Stage(new ScreenViewport());&#10;        Gdx.input.setInputProcessor(stage);&#10;&#10;        skin = new Skin(Gdx.files.internal(&quot;uiskin.json&quot;)); // Asegúrate de tener este skin&#10;&#10;        TextButton jugarBtn = new TextButton(&quot;Jugar&quot;, skin);&#10;        jugarBtn.setSize(200, 60);&#10;        jugarBtn.setPosition(&#10;            Gdx.graphics.getWidth() / 2f - jugarBtn.getWidth() / 2,&#10;            Gdx.graphics.getHeight() / 2f - jugarBtn.getHeight() / 2&#10;        );&#10;        jugarBtn.addListener(new ClickListener() {&#10;            @Override&#10;            public void clicked(InputEvent event, float x, float y) {&#10;                game.setScreen(new PantallaPartida(game));&#10;            }&#10;        });&#10;&#10;        stage.addActor(jugarBtn);&#10;    }&#10;&#10;    @Override&#10;    public void render(float delta) {&#10;        Gdx.gl.glClearColor(0, 0, 0, 1);&#10;        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);&#10;        stage.act(delta);&#10;        stage.draw();&#10;    }&#10;&#10;    @Override&#10;    public void resize(int width, int height) {&#10;        stage.getViewport().update(width, height, true);&#10;    }&#10;&#10;    @Override&#10;    public void pause() {}&#10;&#10;    @Override&#10;    public void resume() {}&#10;&#10;    @Override&#10;    public void hide() {&#10;        stage.dispose();&#10;        skin.dispose();&#10;    }&#10;&#10;    @Override&#10;    public void dispose() {&#10;        stage.dispose();&#10;        skin.dispose();&#10;&#10;" />
              <option name="updatedContent" value="package com.mygdx.game;&#10;&#10;import com.badlogic.gdx.Gdx;&#10;import com.badlogic.gdx.Screen;&#10;import com.badlogic.gdx.graphics.GL20;&#10;import com.badlogic.gdx.scenes.scene2d.Stage;&#10;import com.badlogic.gdx.scenes.scene2d.ui.Skin;&#10;import com.badlogic.gdx.scenes.scene2d.ui.TextButton;&#10;import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;&#10;import com.badlogic.gdx.scenes.scene2d.InputEvent;&#10;import com.badlogic.gdx.utils.viewport.ScreenViewport;&#10;&#10;public class PantallaMenu implements Screen {&#10;    private final MainGame game;&#10;    private Stage stage;&#10;    private Skin skin;&#10;&#10;    public PantallaMenu(MainGame game) {&#10;        this.game = game;&#10;    }&#10;&#10;    @Override&#10;    public void show() {&#10;        stage = new Stage(new ScreenViewport());&#10;        Gdx.input.setInputProcessor(stage);&#10;&#10;        skin = new Skin(Gdx.files.internal(&quot;uiskin.json&quot;)); // Asegúrate de tener este skin&#10;&#10;        TextButton jugarBtn = new TextButton(&quot;Jugar&quot;, skin);&#10;        jugarBtn.setSize(200, 60);&#10;        jugarBtn.setPosition(&#10;            Gdx.graphics.getWidth() / 2f - jugarBtn.getWidth() / 2,&#10;            Gdx.graphics.getHeight() / 2f - jugarBtn.getHeight() / 2&#10;        );&#10;        jugarBtn.addListener(new ClickListener() {&#10;            @Override&#10;            public void clicked(InputEvent event, float x, float y) {&#10;                game.setScreen(new PantallaPartida(game));&#10;            }&#10;        });&#10;&#10;        stage.addActor(jugarBtn);&#10;    }&#10;&#10;    @Override&#10;    public void render(float delta) {&#10;        Gdx.gl.glClearColor(0, 0, 0, 1);&#10;        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);&#10;        stage.act(delta);&#10;        stage.draw();&#10;    }&#10;&#10;    @Override&#10;    public void resize(int width, int height) {&#10;        stage.getViewport().update(width, height, true);&#10;    }&#10;&#10;    @Override&#10;    public void pause() {}&#10;&#10;    @Override&#10;    public void resume() {}&#10;&#10;    @Override&#10;    public void hide() {&#10;        stage.dispose();&#10;        skin.dispose();&#10;    }&#10;&#10;    @Override&#10;    public void dispose() {&#10;        stage.dispose();&#10;        skin.dispose();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/src/com/mygdx/game/PantallaPartida.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/src/com/mygdx/game/PantallaPartida.java" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.mygdx.game;&#10;&#10;import com.badlogic.gdx.Screen;&#10;import com.badlogic.gdx.Gdx;&#10;import com.badlogic.gdx.graphics.GL20;&#10;&#10;public class PantallaPartida implements Screen {&#10;    private final MainGame game;&#10;&#10;    public PantallaPartida(MainGame game) {&#10;        this.game = game;&#10;        // ...aquí puedes inicializar recursos de la partida...&#10;    }&#10;&#10;    @Override&#10;    public void show() {&#10;        // ...código de inicialización de la pantalla de partida...&#10;    }&#10;&#10;    @Override&#10;    public void render(float delta) {&#10;        Gdx.gl.glClearColor(0.1f, 0.1f, 0.1f, 1);&#10;        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);&#10;        // ...lógica y renderizado de la partida...&#10;    }&#10;&#10;    @Override&#10;    public void resize(int width, int height) {&#10;        // ...si necesitas ajustar la vista...&#10;    }&#10;&#10;    @Override&#10;    public void pause() {}&#10;&#10;    @Override&#10;    public void resume() {}&#10;&#10;    @Override&#10;    public void hide() {&#10;        // ...libera recursos si es necesario...&#10;    }&#10;&#10;    @Override&#10;    public void dispose() {&#10;        // ...libera recursos de la partida...&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/src/main/java/com.Envit.Juego/pantallas/PantallaMenu.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/src/main/java/com.Envit.Juego/pantallas/PantallaMenu.java" />
              <option name="originalContent" value="package com.Envit.Juego.pantallas;&#10;&#10;import com.Envit.Juego.Principal;&#10;import com.badlogic.gdx.Gdx;&#10;import com.badlogic.gdx.Screen;&#10;import com.badlogic.gdx.graphics.*;&#10;import com.badlogic.gdx.graphics.g2d.*;&#10;import com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator;&#10;import com.badlogic.gdx.graphics.glutils.ShapeRenderer;&#10;import com.badlogic.gdx.math.Rectangle;&#10;import com.badlogic.gdx.utils.viewport.FitViewport;&#10;import com.badlogic.gdx.utils.viewport.Viewport;&#10;&#10;import java.util.Random;&#10;&#10;public class PantallaMenu implements Screen {&#10;&#10;    private final Principal game;&#10;&#10;    private SpriteBatch batch;&#10;    private ShapeRenderer shapeRenderer;&#10;    private BitmapFont font;&#10;&#10;    private Texture backgroundTexture;&#10;    private Texture optionsBackgroundTexture;&#10;&#10;    private boolean inOptionsMode = false;&#10;&#10;    // Efectos CRT&#10;    private boolean crtEnabled = true;&#10;    private boolean flickerEnabled = true;&#10;    private boolean shakeEnabled = true;&#10;&#10;    private float scanlineOffset = 0f;&#10;    private float crtFlicker = 0f;&#10;&#10;    private Random random = new Random();&#10;&#10;    // Viewport para mantener relación de aspecto&#10;    private static final float VIRTUAL_WIDTH = 1280;&#10;    private static final float VIRTUAL_HEIGHT = 720;&#10;    private Viewport viewport;&#10;&#10;    // UI&#10;    // Eliminados: TextButton, CheckBox, Label, Skin&#10;    // En su lugar, usaremos tus propios assets y lógica manual&#10;&#10;    // Ejemplo de posiciones para tus botones&#10;    private Rectangle btnPlayRect = new Rectangle();&#10;    private Rectangle btnOptionsRect = new Rectangle();&#10;    private Rectangle btnExitRect = new Rectangle();&#10;    private Rectangle btnCloseOptionsRect = new Rectangle();&#10;    private Rectangle chkCRTBox = new Rectangle();&#10;    private Rectangle chkFlickerBox = new Rectangle();&#10;    private Rectangle chkShakeBox = new Rectangle();&#10;&#10;    // Texturas para tus botones (deberás poner los nombres correctos de tus archivos)&#10;    private Texture btnPlayTexture, btnOptionsTexture, btnExitTexture, btnCloseOptionsTexture;&#10;    private Texture chkCheckedTexture, chkUncheckedTexture;&#10;    private Texture titleTexture;&#10;&#10;    public PantallaMenu(final Principal game) {&#10;        this.game = game;&#10;&#10;        batch = new SpriteBatch();&#10;        shapeRenderer = new ShapeRenderer();&#10;&#10;        // Viewport para mantener aspecto&#10;        viewport = new FitViewport(VIRTUAL_WIDTH, VIRTUAL_HEIGHT);&#10;&#10;        // Stage eliminado, ya no se usa Scene2D&#10;        // Cargar tus texturas personalizadas&#10;        loadFont();&#10;        loadBackgrounds();&#10;        loadButtonTextures();&#10;        setButtonRects();&#10;    }&#10;&#10;    private void loadFont() {&#10;        try {&#10;            // Quitar &quot;assets/&quot; de la ruta, solo poner la ruta relativa desde assets&#10;            FreeTypeFontGenerator generator = new FreeTypeFontGenerator(Gdx.files.internal(&quot;fuentes/medieval.ttf&quot;));&#10;            FreeTypeFontGenerator.FreeTypeFontParameter parameter = new FreeTypeFontGenerator.FreeTypeFontParameter();&#10;            parameter.size = 36;&#10;            font = generator.generateFont(parameter);&#10;            generator.dispose();&#10;        } catch (Exception e) {&#10;            font = new BitmapFont(); // fallback default&#10;            Gdx.app.log(&quot;PantallaMenu&quot;, &quot;No se pudo cargar la fuente medieval.ttf, usando fuente por defecto&quot;);&#10;        }&#10;    }&#10;&#10;    private void loadBackgrounds() {&#10;        // Quitar &quot;assets/&quot; de la ruta, solo poner la ruta relativa desde assets&#10;        if (Gdx.files.internal(&quot;fondos/fondo.png&quot;).exists()) {&#10;            backgroundTexture = new Texture(Gdx.files.internal(&quot;fondos/fondo.png&quot;));&#10;            Gdx.app.log(&quot;PantallaMenu&quot;, &quot;Fondo principal cargado correctamente&quot;);&#10;        } else {&#10;            backgroundTexture = null;&#10;            Gdx.app.error(&quot;PantallaMenu&quot;, &quot;No se encontró fondos/fondo.png, usando fondo procedural&quot;);&#10;        }&#10;        if (Gdx.files.internal(&quot;fondos/fondoOpciones.png&quot;).exists()) {&#10;            optionsBackgroundTexture = new Texture(Gdx.files.internal(&quot;fondos/fondoOpciones.png&quot;));&#10;            Gdx.app.log(&quot;PantallaMenu&quot;, &quot;Fondo de opciones cargado correctamente&quot;);&#10;        } else {&#10;            optionsBackgroundTexture = null;&#10;            Gdx.app.error(&quot;PantallaMenu&quot;, &quot;No se encontró fondos/fondoOpciones.png, usando fondo procedural para opciones&quot;);&#10;        }&#10;    }&#10;&#10;    private void loadButtonTextures() {&#10;     /*   // Cambia los nombres por los de tus archivos reales&#10;        btnPlayTexture = tryLoadTexture(&quot;sprites/btn_jugar.png&quot;);&#10;        btnOptionsTexture = tryLoadTexture(&quot;sprites/btn_jugar.png&quot;);&#10;        btnExitTexture = tryLoadTexture(&quot;sprites/btn_jugar.png&quot;);&#10;        btnCloseOptionsTexture = tryLoadTexture(&quot;sprites/btn_jugar.png&quot;);&#10;        chkCheckedTexture = tryLoadTexture(&quot;sprites/btn_jugar.png&quot;);&#10;        chkUncheckedTexture = tryLoadTexture(&quot;sprites/pepi.png&quot;);&#10;        titleTexture = tryLoadTexture(&quot;sprites/btn_jugar.png&quot;);&#10;    */}&#10;&#10;    private Texture tryLoadTexture(String path) {&#10;        if (Gdx.files.internal(path).exists()) {&#10;            return new Texture(Gdx.files.internal(path));&#10;        } else {&#10;            Gdx.app.error(&quot;PantallaMenu&quot;, &quot;No se encontró: &quot; + path);&#10;            return null;&#10;        }&#10;    }&#10;&#10;    private void setButtonRects() {&#10;        float w = VIRTUAL_WIDTH;&#10;        float h = VIRTUAL_HEIGHT;&#10;        float btnW = 240, btnH = 60;&#10;        float espacio = 32;&#10;        float totalH = 3 * btnH + 2 * espacio;&#10;        float startY = h / 2f - totalH / 2f;&#10;&#10;        float centerX = w / 2f - btnW / 2f;&#10;        btnPlayRect.set(centerX, startY + 2 * (btnH + espacio), btnW, btnH);&#10;        btnOptionsRect.set(centerX, startY + (btnH + espacio), btnW, btnH);&#10;        btnExitRect.set(centerX, startY, btnW, btnH);&#10;&#10;        btnCloseOptionsRect.set(centerX, startY, btnW, btnH);&#10;&#10;        // Checkboxes centrados y con separación uniforme debajo de los botones&#10;        float chkW = 32, chkH = 32;&#10;        float chkX = w / 2f - chkW / 2f;&#10;        float chkEspacio = 48;&#10;        float chkStartY = h / 2f - 40;&#10;        chkCRTBox.set(chkX, chkStartY + chkEspacio, chkW, chkH);&#10;        chkFlickerBox.set(chkX, chkStartY, chkW, chkH);&#10;        chkShakeBox.set(chkX, chkStartY - chkEspacio, chkW, chkH);&#10;    }&#10;&#10;    @Override&#10;    public void resize(int width, int height) {&#10;        viewport.update(width, height, true);&#10;        setButtonRects();&#10;    }&#10;&#10;    @Override&#10;    public void render(float delta) {&#10;        // Actualizar lógica efectos CRT&#10;        if (crtEnabled) {&#10;            scanlineOffset += 60 * delta * 0.5f;&#10;            if (scanlineOffset &gt; 4) scanlineOffset = 0;&#10;        }&#10;&#10;        if (flickerEnabled) {&#10;            crtFlicker += 60 * delta * 0.1f;&#10;            if (crtFlicker &gt; Math.PI * 2) crtFlicker = 0;&#10;        }&#10;&#10;        // Limpiar pantalla&#10;        Gdx.gl.glClearColor(0, 0, 0, 1);&#10;        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);&#10;&#10;        // Aplicar viewport antes de dibujar&#10;        viewport.apply();&#10;        batch.setProjectionMatrix(viewport.getCamera().combined);&#10;        shapeRenderer.setProjectionMatrix(viewport.getCamera().combined);&#10;&#10;        batch.begin();&#10;&#10;        // Dibujar fondo (según modo)&#10;        if (!inOptionsMode) {&#10;            if (backgroundTexture != null) {&#10;                batch.draw(backgroundTexture, 0, 0, VIRTUAL_WIDTH, VIRTUAL_HEIGHT);&#10;            } else {&#10;                drawProceduralBackground(batch);&#10;            }&#10;        } else {&#10;            if (optionsBackgroundTexture != null) {&#10;                batch.draw(optionsBackgroundTexture, 0, 0, VIRTUAL_WIDTH, VIRTUAL_HEIGHT);&#10;            } else {&#10;                drawProceduralOptionsBackground(batch);&#10;            }&#10;        }&#10;&#10;        // Dibuja el título&#10;        if (titleTexture != null) {&#10;            batch.draw(titleTexture, VIRTUAL_WIDTH/2f - titleTexture.getWidth()/2f, VIRTUAL_HEIGHT - 120);&#10;        } else if (font != null) {&#10;            font.setColor(Color.CYAN);&#10;            font.getData().setScale(2f);&#10;            font.draw(batch, &quot;Envit&quot;, VIRTUAL_WIDTH/2f - 80, VIRTUAL_HEIGHT - 80);&#10;        }&#10;&#10;        // Dibuja los botones principales&#10;        if (!inOptionsMode) {&#10;            drawButton(batch, btnPlayTexture, btnPlayRect, &quot;JUGAR&quot;);&#10;            drawButton(batch, btnOptionsTexture, btnOptionsRect, &quot;OPCIONES&quot;);&#10;            drawButton(batch, btnExitTexture, btnExitRect, &quot;SALIR&quot;);&#10;        } else {&#10;            drawButton(batch, btnCloseOptionsTexture, btnCloseOptionsRect, &quot;CERRAR&quot;);&#10;            // Checkboxes&#10;            drawCheckbox(batch, chkCRTBox, crtEnabled, &quot;Efectos CRT&quot;);&#10;            drawCheckbox(batch, chkFlickerBox, flickerEnabled, &quot;Destellos&quot;);&#10;            drawCheckbox(batch, chkShakeBox, shakeEnabled, &quot;Temblor&quot;);&#10;        }&#10;        batch.end();&#10;&#10;        // Dibujar efecto CRT&#10;        if (crtEnabled) {&#10;            drawCRTEffect();&#10;        }&#10;&#10;        // Manejo de input manual para botones y checkboxes&#10;        handleInput();&#10;    }&#10;&#10;    private void drawButton(SpriteBatch batch, Texture texture, Rectangle rect, String texto) {&#10;        // Calcula la posición del mouse en coordenadas del viewport&#10;        com.badlogic.gdx.math.Vector2 mouse = viewport.unproject(new com.badlogic.gdx.math.Vector2(Gdx.input.getX(), Gdx.input.getY()));&#10;        boolean hovered = rect.contains(mouse.x, mouse.y);&#10;&#10;        if (texture != null) {&#10;            batch.setColor(hovered ? new Color(0.7f, 1f, 1f, 1f) : Color.WHITE);&#10;            batch.draw(texture, rect.x, rect.y, rect.width, rect.height);&#10;            batch.setColor(Color.WHITE);&#10;        } else if (font != null) {&#10;            // Fondo simple para el botón&#10;            batch.setColor(hovered ? new Color(0,1,1,0.25f) : new Color(0,0,0,0.25f));&#10;            batch.draw(getWhitePixel(), rect.x, rect.y, rect.width, rect.height);&#10;            batch.setColor(Color.WHITE);&#10;            font.setColor(hovered ? Color.CYAN : Color.WHITE);&#10;            font.getData().setScale(1.2f);&#10;            font.draw(batch, texto, rect.x + rect.width/2 - 50, rect.y + rect.height/2 + 15);&#10;        }&#10;    }&#10;&#10;    private void drawCheckbox(SpriteBatch batch, Rectangle rect, boolean checked, String label) {&#10;        com.badlogic.gdx.math.Vector2 mouse = viewport.unproject(new com.badlogic.gdx.math.Vector2(Gdx.input.getX(), Gdx.input.getY()));&#10;        boolean hovered = rect.contains(mouse.x, mouse.y);&#10;        Texture tex = checked ? chkCheckedTexture : chkUncheckedTexture;&#10;        if (tex != null) {&#10;            batch.setColor(hovered ? new Color(0.7f, 1f, 1f, 1f) : Color.WHITE);&#10;            batch.draw(tex, rect.x, rect.y, rect.width, rect.height);&#10;            batch.setColor(Color.WHITE);&#10;        } else {&#10;            batch.setColor(hovered ? new Color(0,1,1,0.25f) : new Color(0,0,0,0.25f));&#10;            batch.draw(getWhitePixel(), rect.x, rect.y, rect.width, rect.height);&#10;            batch.setColor(Color.WHITE);&#10;        }&#10;        if (font != null) {&#10;            font.setColor(hovered ? Color.CYAN : Color.WHITE);&#10;            font.getData().setScale(1f);&#10;            font.draw(batch, label, rect.x + rect.width + 12, rect.y + rect.height - 8);&#10;        }&#10;    }&#10;&#10;    private void handleInput() {&#10;        if (Gdx.input.justTouched()) {&#10;            // Para input, usamos el método unproject del viewport&#10;            com.badlogic.gdx.math.Vector2 touch = viewport.unproject(new com.badlogic.gdx.math.Vector2(Gdx.input.getX(), Gdx.input.getY()));&#10;            float x = touch.x;&#10;            float y = touch.y;&#10;&#10;            if (!inOptionsMode) {&#10;                if (btnPlayRect.contains(x, y)) startGame();&#10;                else if (btnOptionsRect.contains(x, y)) toggleOptions();&#10;                else if (btnExitRect.contains(x, y)) Gdx.app.exit();&#10;            } else {&#10;                if (btnCloseOptionsRect.contains(x, y)) toggleOptions();&#10;                else if (chkCRTBox.contains(x, y)) crtEnabled = !crtEnabled;&#10;                else if (chkFlickerBox.contains(x, y)) flickerEnabled = !flickerEnabled;&#10;                else if (chkShakeBox.contains(x, y)) shakeEnabled = !shakeEnabled;&#10;            }&#10;        }&#10;    }&#10;&#10;    private void toggleOptions() {&#10;        inOptionsMode = !inOptionsMode;&#10;    }&#10;&#10;    private void startGame() {&#10;        // Cambia a la pantalla de partida&#10;        game.setScreen(new PantallaPartida(game));&#10;    }&#10;&#10;    private void drawProceduralBackground(SpriteBatch batch) {&#10;        // Para algo simple, dibujamos un fondo con gradient manual (puede ser con ShapeRenderer si querés)&#10;        batch.end();&#10;&#10;        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);&#10;        int w = Gdx.graphics.getWidth();&#10;        int h = Gdx.graphics.getHeight();&#10;&#10;        // Gradient vertical manual simulando tu fondo original&#10;        shapeRenderer.rect(0, 0, w, h, new Color(0.04f, 0.04f, 0.12f,1), new Color(0.16f, 0.04f, 0.24f,1), new Color(0.24f, 0.08f, 0.39f,1), new Color(0.04f, 0.16f, 0.39f,1));&#10;&#10;        // Elementos gráficos retro simples&#10;        for (int i = 0; i &lt; 15; i++) {&#10;            float x = random.nextInt(w);&#10;            float y = random.nextInt(h);&#10;            float size = random.nextInt(150) + 50;&#10;            shapeRenderer.setColor(0, 1, 1, 0.12f);&#10;            shapeRenderer.circle(x, y, size);&#10;        }&#10;&#10;        // Líneas de circuito&#10;        shapeRenderer.setColor(1, 0, 1, 0.16f);&#10;        for (int i = 0; i &lt; 20; i++) {&#10;            float x1 = random.nextInt(w);&#10;            float y1 = random.nextInt(h);&#10;            float x2 = x1 + random.nextInt(200) - 100;&#10;            float y2 = y1 + random.nextInt(200) - 100;&#10;            shapeRenderer.rectLine(x1, y1, x2, y2, 2);&#10;        }&#10;&#10;        shapeRenderer.end();&#10;&#10;        batch.begin();&#10;    }&#10;&#10;    private void drawProceduralOptionsBackground(SpriteBatch batch) {&#10;        batch.end();&#10;&#10;        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);&#10;        int w = Gdx.graphics.getWidth();&#10;        int h = Gdx.graphics.getHeight();&#10;&#10;        // Gradientes para opciones (como en tu código)&#10;        // Parte 1&#10;        shapeRenderer.rect(0, 0, w / 2, h / 2, new Color(0.04f, 0.04f, 0.12f,1), new Color(0.16f, 0.04f, 0.24f,1), new Color(0.24f, 0.08f, 0.39f,1), new Color(0.04f, 0.16f, 0.39f,1));&#10;        // Parte 2&#10;        shapeRenderer.rect(w / 2, 0, w / 2, h, new Color(0.24f, 0.08f, 0.39f, 0.39f), new Color(0.08f, 0.16f, 0.39f, 0.39f), new Color(0.08f, 0.16f, 0.39f, 0.39f), new Color(0.24f, 0.08f, 0.39f, 0.39f));&#10;&#10;        shapeRenderer.end();&#10;&#10;        batch.begin();&#10;    }&#10;&#10;    private void drawCRTEffect() {&#10;        Gdx.gl.glEnable(GL20.GL_BLEND);&#10;        shapeRenderer.setProjectionMatrix(viewport.getCamera().combined);&#10;        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);&#10;&#10;        int w = (int)VIRTUAL_WIDTH;&#10;        int h = (int)VIRTUAL_HEIGHT;&#10;&#10;        // Líneas de escaneo horizontales (más uniformes)&#10;        shapeRenderer.setColor(0, 0, 0, 0.13f);&#10;        for (int y = (int) scanlineOffset; y &lt; h; y += 3) {&#10;            shapeRenderer.rect(0, y, w, 1);&#10;        }&#10;&#10;        // Líneas verticales ocasionales (más sutiles)&#10;        if (random.nextInt(60) &lt; 2) {&#10;            shapeRenderer.setColor(0, 0, 0, 0.06f);&#10;            for (int x = 0; x &lt; w; x += 2) {&#10;                shapeRenderer.rect(x, 0, 1, h);&#10;            }&#10;        }&#10;&#10;        shapeRenderer.end();&#10;&#10;        // Flicker (destello global sutil)&#10;        if (flickerEnabled &amp;&amp; random.nextInt(100) &lt; 8) {&#10;            batch.begin();&#10;            Color flickerColor = new Color(1,1,1, 0.04f + 0.07f * (float)Math.sin(crtFlicker));&#10;            batch.setColor(flickerColor);&#10;            batch.draw(getWhitePixel(), 0, 0, VIRTUAL_WIDTH, VIRTUAL_HEIGHT);&#10;            batch.setColor(Color.WHITE);&#10;            batch.end();&#10;        }&#10;&#10;        // Ruido estático (más centrado y menos denso)&#10;        if (random.nextInt(150) &lt; 2) {&#10;            shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);&#10;            for (int i = 0; i &lt; 40; i++) {&#10;                float x = random.nextInt(w);&#10;                float y = random.nextInt(h);&#10;                float alpha = random.nextFloat() * 0.2f;&#10;                shapeRenderer.setColor(1, 1, 1, alpha);&#10;                shapeRenderer.rect(x, y, 2, 2);&#10;            }&#10;            shapeRenderer.end();&#10;        }&#10;&#10;        // Distorsión horizontal ocasional (temblor)&#10;        if (shakeEnabled &amp;&amp; random.nextInt(300) &lt; 2) {&#10;            shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);&#10;            int distortY = random.nextInt(h);&#10;            shapeRenderer.setColor(1, 1, 1, 0.08f);&#10;            shapeRenderer.rect(0, distortY, w, 3);&#10;            shapeRenderer.end();&#10;        }&#10;    }&#10;&#10;    // Textura 1x1 blanca para dibujar rectángulos simples&#10;    private Texture whitePixel;&#10;&#10;    private Texture getWhitePixel() {&#10;        if (whitePixel == null) {&#10;            Pixmap pixmap = new Pixmap(1,1, Pixmap.Format.RGBA8888);&#10;            pixmap.setColor(Color.WHITE);&#10;            pixmap.fill();&#10;            whitePixel = new Texture(pixmap);&#10;            pixmap.dispose();&#10;        }&#10;        return whitePixel;&#10;    }&#10;&#10;    @Override&#10;    public void pause() {&#10;        // no necesario&#10;    }&#10;&#10;    @Override&#10;    public void resume() {&#10;        // no necesario&#10;    }&#10;&#10;    @Override&#10;    public void hide() {&#10;        // no necesario&#10;    }&#10;&#10;    @Override&#10;    public void show() {&#10;        // No es necesario&#10;    }&#10;&#10;    @Override&#10;    public void dispose() {&#10;        batch.dispose();&#10;        shapeRenderer.dispose();&#10;        if (backgroundTexture != null) backgroundTexture.dispose();&#10;        if (optionsBackgroundTexture != null) optionsBackgroundTexture.dispose();&#10;        if (whitePixel != null) whitePixel.dispose();&#10;        if (font != null) font.dispose();&#10;        if (btnPlayTexture != null) btnPlayTexture.dispose();&#10;        if (btnOptionsTexture != null) btnOptionsTexture.dispose();&#10;        if (btnExitTexture != null) btnExitTexture.dispose();&#10;        if (btnCloseOptionsTexture != null) btnCloseOptionsTexture.dispose();&#10;        if (chkCheckedTexture != null) chkCheckedTexture.dispose();&#10;        if (chkUncheckedTexture != null) chkUncheckedTexture.dispose();&#10;        if (titleTexture != null) titleTexture.dispose();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.Envit.Juego.pantallas;&#10;&#10;import com.Envit.Juego.Principal;&#10;import com.badlogic.gdx.Gdx;&#10;import com.badlogic.gdx.Screen;&#10;import com.badlogic.gdx.graphics.*;&#10;import com.badlogic.gdx.graphics.g2d.*;&#10;import com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator;&#10;import com.badlogic.gdx.graphics.glutils.ShapeRenderer;&#10;import com.badlogic.gdx.math.Rectangle;&#10;import com.badlogic.gdx.utils.viewport.FitViewport;&#10;import com.badlogic.gdx.utils.viewport.Viewport;&#10;&#10;import java.util.Random;&#10;&#10;public class PantallaMenu implements Screen {&#10;&#10;    private final Principal game;&#10;&#10;    private SpriteBatch batch;&#10;    private ShapeRenderer shapeRenderer;&#10;    private BitmapFont font;&#10;&#10;    private Texture backgroundTexture;&#10;    private Texture optionsBackgroundTexture;&#10;&#10;    private boolean inOptionsMode = false;&#10;&#10;    // Efectos CRT&#10;    private boolean crtEnabled = true;&#10;    private boolean flickerEnabled = true;&#10;    private boolean shakeEnabled = true;&#10;&#10;    private float scanlineOffset = 0f;&#10;    private float crtFlicker = 0f;&#10;&#10;    private Random random = new Random();&#10;&#10;    // Viewport para mantener relación de aspecto&#10;    private static final float VIRTUAL_WIDTH = 1280;&#10;    private static final float VIRTUAL_HEIGHT = 720;&#10;    private Viewport viewport;&#10;&#10;    // UI&#10;    // Eliminados: TextButton, CheckBox, Label, Skin&#10;    // En su lugar, usaremos tus propios assets y lógica manual&#10;&#10;    // Ejemplo de posiciones para tus botones&#10;    private Rectangle btnPlayRect = new Rectangle();&#10;    private Rectangle btnOptionsRect = new Rectangle();&#10;    private Rectangle btnExitRect = new Rectangle();&#10;    private Rectangle btnCloseOptionsRect = new Rectangle();&#10;    private Rectangle chkCRTBox = new Rectangle();&#10;    private Rectangle chkFlickerBox = new Rectangle();&#10;    private Rectangle chkShakeBox = new Rectangle();&#10;&#10;    // Texturas para tus botones (deberás poner los nombres correctos de tus archivos)&#10;    private Texture btnPlayTexture, btnOptionsTexture, btnExitTexture, btnCloseOptionsTexture;&#10;    private Texture chkCheckedTexture, chkUncheckedTexture;&#10;    private Texture titleTexture;&#10;&#10;    public PantallaMenu(final Principal game) {&#10;        this.game = game;&#10;&#10;        batch = new SpriteBatch();&#10;        shapeRenderer = new ShapeRenderer();&#10;&#10;        // Viewport para mantener aspecto&#10;        viewport = new FitViewport(VIRTUAL_WIDTH, VIRTUAL_HEIGHT);&#10;&#10;        // Stage eliminado, ya no se usa Scene2D&#10;        // Cargar tus texturas personalizadas&#10;        loadFont();&#10;        loadBackgrounds();&#10;        loadButtonTextures();&#10;        setButtonRects();&#10;    }&#10;&#10;    private void loadFont() {&#10;        try {&#10;            // Quitar &quot;assets/&quot; de la ruta, solo poner la ruta relativa desde assets&#10;            FreeTypeFontGenerator generator = new FreeTypeFontGenerator(Gdx.files.internal(&quot;fuentes/medieval.ttf&quot;));&#10;            FreeTypeFontGenerator.FreeTypeFontParameter parameter = new FreeTypeFontGenerator.FreeTypeFontParameter();&#10;            parameter.size = 36;&#10;            font = generator.generateFont(parameter);&#10;            generator.dispose();&#10;        } catch (Exception e) {&#10;            font = new BitmapFont(); // fallback default&#10;            Gdx.app.log(&quot;PantallaMenu&quot;, &quot;No se pudo cargar la fuente medieval.ttf, usando fuente por defecto&quot;);&#10;        }&#10;    }&#10;&#10;    private void loadBackgrounds() {&#10;        // Quitar &quot;assets/&quot; de la ruta, solo poner la ruta relativa desde assets&#10;        if (Gdx.files.internal(&quot;fondos/fondo.png&quot;).exists()) {&#10;            backgroundTexture = new Texture(Gdx.files.internal(&quot;fondos/fondo.png&quot;));&#10;            Gdx.app.log(&quot;PantallaMenu&quot;, &quot;Fondo principal cargado correctamente&quot;);&#10;        } else {&#10;            backgroundTexture = null;&#10;            Gdx.app.error(&quot;PantallaMenu&quot;, &quot;No se encontró fondos/fondo.png, usando fondo procedural&quot;);&#10;        }&#10;        if (Gdx.files.internal(&quot;fondos/fondoOpciones.png&quot;).exists()) {&#10;            optionsBackgroundTexture = new Texture(Gdx.files.internal(&quot;fondos/fondoOpciones.png&quot;));&#10;            Gdx.app.log(&quot;PantallaMenu&quot;, &quot;Fondo de opciones cargado correctamente&quot;);&#10;        } else {&#10;            optionsBackgroundTexture = null;&#10;            Gdx.app.error(&quot;PantallaMenu&quot;, &quot;No se encontró fondos/fondoOpciones.png, usando fondo procedural para opciones&quot;);&#10;        }&#10;    }&#10;&#10;    private void loadButtonTextures() {&#10;     /*   // Cambia los nombres por los de tus archivos reales&#10;        btnPlayTexture = tryLoadTexture(&quot;sprites/btn_jugar.png&quot;);&#10;        btnOptionsTexture = tryLoadTexture(&quot;sprites/btn_jugar.png&quot;);&#10;        btnExitTexture = tryLoadTexture(&quot;sprites/btn_jugar.png&quot;);&#10;        btnCloseOptionsTexture = tryLoadTexture(&quot;sprites/btn_jugar.png&quot;);&#10;        chkCheckedTexture = tryLoadTexture(&quot;sprites/btn_jugar.png&quot;);&#10;        chkUncheckedTexture = tryLoadTexture(&quot;sprites/pepi.png&quot;);&#10;        titleTexture = tryLoadTexture(&quot;sprites/btn_jugar.png&quot;);&#10;    */}&#10;&#10;    private Texture tryLoadTexture(String path) {&#10;        if (Gdx.files.internal(path).exists()) {&#10;            return new Texture(Gdx.files.internal(path));&#10;        } else {&#10;            Gdx.app.error(&quot;PantallaMenu&quot;, &quot;No se encontró: &quot; + path);&#10;            return null;&#10;        }&#10;    }&#10;&#10;    private void setButtonRects() {&#10;        float w = VIRTUAL_WIDTH;&#10;        float h = VIRTUAL_HEIGHT;&#10;        float btnW = 240, btnH = 60;&#10;        float espacio = 32;&#10;        float totalH = 3 * btnH + 2 * espacio;&#10;        float startY = h / 2f - totalH / 2f;&#10;&#10;        float centerX = w / 2f - btnW / 2f;&#10;        btnPlayRect.set(centerX, startY + 2 * (btnH + espacio), btnW, btnH);&#10;        btnOptionsRect.set(centerX, startY + (btnH + espacio), btnW, btnH);&#10;        btnExitRect.set(centerX, startY, btnW, btnH);&#10;&#10;        btnCloseOptionsRect.set(centerX, startY, btnW, btnH);&#10;&#10;        // Checkboxes perfectamente centrados debajo de los botones&#10;        float chkW = 32, chkH = 32;&#10;        float chkEspacio = 48;&#10;        float chkTotalH = 3 * chkH + 2 * chkEspacio;&#10;        float chkStartY = h / 2f - chkTotalH / 2f - 80; // Debajo de los botones&#10;        float chkX = w / 2f - chkW / 2f;&#10;        chkCRTBox.set(chkX, chkStartY + 2 * (chkH + chkEspacio), chkW, chkH);&#10;        chkFlickerBox.set(chkX, chkStartY + (chkH + chkEspacio), chkW, chkH);&#10;        chkShakeBox.set(chkX, chkStartY, chkW, chkH);&#10;    }&#10;&#10;    @Override&#10;    public void resize(int width, int height) {&#10;        viewport.update(width, height, true);&#10;        setButtonRects();&#10;    }&#10;&#10;    @Override&#10;    public void render(float delta) {&#10;        // Actualizar lógica efectos CRT&#10;        if (crtEnabled) {&#10;            scanlineOffset += 60 * delta * 0.5f;&#10;            if (scanlineOffset &gt; 4) scanlineOffset = 0;&#10;        }&#10;&#10;        if (flickerEnabled) {&#10;            crtFlicker += 60 * delta * 0.1f;&#10;            if (crtFlicker &gt; Math.PI * 2) crtFlicker = 0;&#10;        }&#10;&#10;        // Limpiar pantalla&#10;        Gdx.gl.glClearColor(0, 0, 0, 1);&#10;        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);&#10;&#10;        // Aplicar viewport antes de dibujar&#10;        viewport.apply();&#10;        batch.setProjectionMatrix(viewport.getCamera().combined);&#10;        shapeRenderer.setProjectionMatrix(viewport.getCamera().combined);&#10;&#10;        batch.begin();&#10;&#10;        // Dibujar fondo (según modo)&#10;        if (!inOptionsMode) {&#10;            if (backgroundTexture != null) {&#10;                batch.draw(backgroundTexture, 0, 0, VIRTUAL_WIDTH, VIRTUAL_HEIGHT);&#10;            } else {&#10;                drawProceduralBackground(batch);&#10;            }&#10;        } else {&#10;            if (optionsBackgroundTexture != null) {&#10;                batch.draw(optionsBackgroundTexture, 0, 0, VIRTUAL_WIDTH, VIRTUAL_HEIGHT);&#10;            } else {&#10;                drawProceduralOptionsBackground(batch);&#10;            }&#10;        }&#10;&#10;        // Dibuja el título&#10;        if (titleTexture != null) {&#10;            batch.draw(titleTexture, VIRTUAL_WIDTH/2f - titleTexture.getWidth()/2f, VIRTUAL_HEIGHT - 120);&#10;        } else if (font != null) {&#10;            font.setColor(Color.CYAN);&#10;            font.getData().setScale(2f);&#10;            font.draw(batch, &quot;Envit&quot;, VIRTUAL_WIDTH/2f - 80, VIRTUAL_HEIGHT - 80);&#10;        }&#10;&#10;        // Dibuja los botones principales&#10;        if (!inOptionsMode) {&#10;            drawButton(batch, btnPlayTexture, btnPlayRect, &quot;JUGAR&quot;);&#10;            drawButton(batch, btnOptionsTexture, btnOptionsRect, &quot;OPCIONES&quot;);&#10;            drawButton(batch, btnExitTexture, btnExitRect, &quot;SALIR&quot;);&#10;        } else {&#10;            drawButton(batch, btnCloseOptionsTexture, btnCloseOptionsRect, &quot;CERRAR&quot;);&#10;            // Checkboxes&#10;            drawCheckbox(batch, chkCRTBox, crtEnabled, &quot;Efectos CRT&quot;);&#10;            drawCheckbox(batch, chkFlickerBox, flickerEnabled, &quot;Destellos&quot;);&#10;            drawCheckbox(batch, chkShakeBox, shakeEnabled, &quot;Temblor&quot;);&#10;        }&#10;        batch.end();&#10;&#10;        // Dibujar efecto CRT&#10;        if (crtEnabled) {&#10;            drawCRTEffect();&#10;        }&#10;&#10;        // Manejo de input manual para botones y checkboxes&#10;        handleInput();&#10;    }&#10;&#10;    private void drawButton(SpriteBatch batch, Texture texture, Rectangle rect, String texto) {&#10;        com.badlogic.gdx.math.Vector2 mouse = viewport.unproject(new com.badlogic.gdx.math.Vector2(Gdx.input.getX(), Gdx.input.getY()));&#10;        boolean hovered = rect.contains(mouse.x, mouse.y);&#10;&#10;        // Fondo centrado y hover uniforme&#10;        if (texture != null) {&#10;            batch.setColor(hovered ? new Color(0.7f, 1f, 1f, 1f) : Color.WHITE);&#10;            batch.draw(texture, rect.x, rect.y, rect.width, rect.height);&#10;            batch.setColor(Color.WHITE);&#10;        } else if (font != null) {&#10;            batch.setColor(hovered ? new Color(0,1,1,0.25f) : new Color(0,0,0,0.25f));&#10;            batch.draw(getWhitePixel(), rect.x, rect.y, rect.width, rect.height);&#10;            batch.setColor(Color.WHITE);&#10;            font.setColor(hovered ? Color.CYAN : Color.WHITE);&#10;            font.getData().setScale(1.2f);&#10;            // Centrado horizontal y vertical&#10;            float textWidth = font.getRegion().getRegionWidth();&#10;            float textX = rect.x + rect.width / 2 - 50;&#10;            float textY = rect.y + rect.height / 2 + 15;&#10;            font.draw(batch, texto, textX, textY);&#10;        }&#10;    }&#10;&#10;    private void drawCheckbox(SpriteBatch batch, Rectangle rect, boolean checked, String label) {&#10;        com.badlogic.gdx.math.Vector2 mouse = viewport.unproject(new com.badlogic.gdx.math.Vector2(Gdx.input.getX(), Gdx.input.getY()));&#10;        boolean hovered = rect.contains(mouse.x, mouse.y);&#10;        Texture tex = checked ? chkCheckedTexture : chkUncheckedTexture;&#10;        if (tex != null) {&#10;            batch.setColor(hovered ? new Color(0.7f, 1f, 1f, 1f) : Color.WHITE);&#10;            batch.draw(tex, rect.x, rect.y, rect.width, rect.height);&#10;            batch.setColor(Color.WHITE);&#10;        } else {&#10;            batch.setColor(hovered ? new Color(0,1,1,0.25f) : new Color(0,0,0,0.25f));&#10;            batch.draw(getWhitePixel(), rect.x, rect.y, rect.width, rect.height);&#10;            batch.setColor(Color.WHITE);&#10;        }&#10;        if (font != null) {&#10;            font.setColor(hovered ? Color.CYAN : Color.WHITE);&#10;            font.getData().setScale(1f);&#10;            // Centrado vertical respecto a la caja&#10;            float labelX = rect.x + rect.width + 16;&#10;            float labelY = rect.y + rect.height - 8;&#10;            font.draw(batch, label, labelX, labelY);&#10;        }&#10;    }&#10;&#10;    private void handleInput() {&#10;        if (Gdx.input.justTouched()) {&#10;            // Para input, usamos el método unproject del viewport&#10;            com.badlogic.gdx.math.Vector2 touch = viewport.unproject(new com.badlogic.gdx.math.Vector2(Gdx.input.getX(), Gdx.input.getY()));&#10;            float x = touch.x;&#10;            float y = touch.y;&#10;&#10;            if (!inOptionsMode) {&#10;                if (btnPlayRect.contains(x, y)) startGame();&#10;                else if (btnOptionsRect.contains(x, y)) toggleOptions();&#10;                else if (btnExitRect.contains(x, y)) Gdx.app.exit();&#10;            } else {&#10;                if (btnCloseOptionsRect.contains(x, y)) toggleOptions();&#10;                else if (chkCRTBox.contains(x, y)) crtEnabled = !crtEnabled;&#10;                else if (chkFlickerBox.contains(x, y)) flickerEnabled = !flickerEnabled;&#10;                else if (chkShakeBox.contains(x, y)) shakeEnabled = !shakeEnabled;&#10;            }&#10;        }&#10;    }&#10;&#10;    private void toggleOptions() {&#10;        inOptionsMode = !inOptionsMode;&#10;    }&#10;&#10;    private void startGame() {&#10;        // Cambia a la pantalla de partida&#10;        game.setScreen(new PantallaPartida(game));&#10;    }&#10;&#10;    private void drawProceduralBackground(SpriteBatch batch) {&#10;        // Para algo simple, dibujamos un fondo con gradient manual (puede ser con ShapeRenderer si querés)&#10;        batch.end();&#10;&#10;        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);&#10;        int w = Gdx.graphics.getWidth();&#10;        int h = Gdx.graphics.getHeight();&#10;&#10;        // Gradient vertical manual simulando tu fondo original&#10;        shapeRenderer.rect(0, 0, w, h, new Color(0.04f, 0.04f, 0.12f,1), new Color(0.16f, 0.04f, 0.24f,1), new Color(0.24f, 0.08f, 0.39f,1), new Color(0.04f, 0.16f, 0.39f,1));&#10;&#10;        // Elementos gráficos retro simples&#10;        for (int i = 0; i &lt; 15; i++) {&#10;            float x = random.nextInt(w);&#10;            float y = random.nextInt(h);&#10;            float size = random.nextInt(150) + 50;&#10;            shapeRenderer.setColor(0, 1, 1, 0.12f);&#10;            shapeRenderer.circle(x, y, size);&#10;        }&#10;&#10;        // Líneas de circuito&#10;        shapeRenderer.setColor(1, 0, 1, 0.16f);&#10;        for (int i = 0; i &lt; 20; i++) {&#10;            float x1 = random.nextInt(w);&#10;            float y1 = random.nextInt(h);&#10;            float x2 = x1 + random.nextInt(200) - 100;&#10;            float y2 = y1 + random.nextInt(200) - 100;&#10;            shapeRenderer.rectLine(x1, y1, x2, y2, 2);&#10;        }&#10;&#10;        shapeRenderer.end();&#10;&#10;        batch.begin();&#10;    }&#10;&#10;    private void drawProceduralOptionsBackground(SpriteBatch batch) {&#10;        batch.end();&#10;&#10;        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);&#10;        int w = Gdx.graphics.getWidth();&#10;        int h = Gdx.graphics.getHeight();&#10;&#10;        // Gradientes para opciones (como en tu código)&#10;        // Parte 1&#10;        shapeRenderer.rect(0, 0, w / 2, h / 2, new Color(0.04f, 0.04f, 0.12f,1), new Color(0.16f, 0.04f, 0.24f,1), new Color(0.24f, 0.08f, 0.39f,1), new Color(0.04f, 0.16f, 0.39f,1));&#10;        // Parte 2&#10;        shapeRenderer.rect(w / 2, 0, w / 2, h, new Color(0.24f, 0.08f, 0.39f, 0.39f), new Color(0.08f, 0.16f, 0.39f, 0.39f), new Color(0.08f, 0.16f, 0.39f, 0.39f), new Color(0.24f, 0.08f, 0.39f, 0.39f));&#10;&#10;        shapeRenderer.end();&#10;&#10;        batch.begin();&#10;    }&#10;&#10;    private void drawCRTEffect() {&#10;        Gdx.gl.glEnable(GL20.GL_BLEND);&#10;        shapeRenderer.setProjectionMatrix(viewport.getCamera().combined);&#10;        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);&#10;&#10;        int w = (int)VIRTUAL_WIDTH;&#10;        int h = (int)VIRTUAL_HEIGHT;&#10;&#10;        // Líneas de escaneo horizontales perfectamente alineadas&#10;        shapeRenderer.setColor(0, 0, 0, 0.13f);&#10;        for (int y = (int) scanlineOffset; y &lt; h; y += 3) {&#10;            shapeRenderer.rect(0, y, w, 1);&#10;        }&#10;&#10;        // Líneas verticales ocasionales&#10;        if (random.nextInt(60) &lt; 2) {&#10;            shapeRenderer.setColor(0, 0, 0, 0.06f);&#10;            for (int x = 0; x &lt; w; x += 2) {&#10;                shapeRenderer.rect(x, 0, 1, h);&#10;            }&#10;        }&#10;&#10;        shapeRenderer.end();&#10;&#10;        // Flicker (destello global sutil y centrado)&#10;        if (flickerEnabled &amp;&amp; random.nextInt(100) &lt; 8) {&#10;            batch.begin();&#10;            Color flickerColor = new Color(1,1,1, 0.04f + 0.07f * (float)Math.sin(crtFlicker));&#10;            batch.setColor(flickerColor);&#10;            batch.draw(getWhitePixel(), 0, 0, VIRTUAL_WIDTH, VIRTUAL_HEIGHT);&#10;            batch.setColor(Color.WHITE);&#10;            batch.end();&#10;        }&#10;&#10;        // Ruido estático centrado&#10;        if (random.nextInt(150) &lt; 2) {&#10;            shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);&#10;            for (int i = 0; i &lt; 40; i++) {&#10;                float x = random.nextInt(w);&#10;                float y = random.nextInt(h);&#10;                float alpha = random.nextFloat() * 0.2f;&#10;                shapeRenderer.setColor(1, 1, 1, alpha);&#10;                shapeRenderer.rect(x, y, 2, 2);&#10;            }&#10;            shapeRenderer.end();&#10;        }&#10;&#10;        // Distorsión horizontal ocasional (temblor)&#10;        if (shakeEnabled &amp;&amp; random.nextInt(300) &lt; 2) {&#10;            shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);&#10;            int distortY = random.nextInt(h);&#10;            shapeRenderer.setColor(1, 1, 1, 0.08f);&#10;            shapeRenderer.rect(0, distortY, w, 3);&#10;            shapeRenderer.end();&#10;        }&#10;    }&#10;&#10;    // Textura 1x1 blanca para dibujar rectángulos simples&#10;    private Texture whitePixel;&#10;&#10;    private Texture getWhitePixel() {&#10;        if (whitePixel == null) {&#10;            Pixmap pixmap = new Pixmap(1,1, Pixmap.Format.RGBA8888);&#10;            pixmap.setColor(Color.WHITE);&#10;            pixmap.fill();&#10;            whitePixel = new Texture(pixmap);&#10;            pixmap.dispose();&#10;        }&#10;        return whitePixel;&#10;    }&#10;&#10;    @Override&#10;    public void pause() {&#10;        // no necesario&#10;    }&#10;&#10;    @Override&#10;    public void resume() {&#10;        // no necesario&#10;    }&#10;&#10;    @Override&#10;    public void hide() {&#10;        // no necesario&#10;    }&#10;&#10;    @Override&#10;    public void show() {&#10;        // No es necesario&#10;    }&#10;&#10;    @Override&#10;    public void dispose() {&#10;        batch.dispose();&#10;        shapeRenderer.dispose();&#10;        if (backgroundTexture != null) backgroundTexture.dispose();&#10;        if (optionsBackgroundTexture != null) optionsBackgroundTexture.dispose();&#10;        if (whitePixel != null) whitePixel.dispose();&#10;        if (font != null) font.dispose();&#10;        if (btnPlayTexture != null) btnPlayTexture.dispose();&#10;        if (btnOptionsTexture != null) btnOptionsTexture.dispose();&#10;        if (btnExitTexture != null) btnExitTexture.dispose();&#10;        if (btnCloseOptionsTexture != null) btnCloseOptionsTexture.dispose();&#10;        if (chkCheckedTexture != null) chkCheckedTexture.dispose();&#10;        if (chkUncheckedTexture != null) chkUncheckedTexture.dispose();&#10;        if (titleTexture != null) titleTexture.dispose();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/src/main/java/com.Envit.Juego/pantallas/PantallaPartida.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/src/main/java/com.Envit.Juego/pantallas/PantallaPartida.java" />
              <option name="originalContent" value="package com.Envit.Juego.pantallas;&#10;&#10;import com.Envit.Juego.Principal;&#10;import com.badlogic.gdx.Gdx;&#10;import com.badlogic.gdx.Screen;&#10;import com.badlogic.gdx.graphics.Color;&#10;import com.badlogic.gdx.graphics.GL20;&#10;import com.badlogic.gdx.graphics.Texture;&#10;import com.badlogic.gdx.graphics.g2d.SpriteBatch;&#10;import com.badlogic.gdx.graphics.g2d.TextureRegion;&#10;import com.badlogic.gdx.math.MathUtils;&#10;import com.badlogic.gdx.utils.viewport.FitViewport;&#10;import com.badlogic.gdx.utils.viewport.Viewport;&#10;&#10;public class PantallaPartida implements Screen {&#10;    private final Principal game;&#10;    private SpriteBatch batch;&#10;    private Texture barajaTexture;&#10;    private TextureRegion[][] cartas; // [fila][columna]&#10;    private int[][] cartasMostradas; // [3][2] -&gt; fila, columna&#10;&#10;    // Viewport para mantener relación de aspecto&#10;    private static final float VIRTUAL_WIDTH = 1280;&#10;    private static final float VIRTUAL_HEIGHT = 720;&#10;    private Viewport viewport;&#10;&#10;    public PantallaPartida(Principal game) {&#10;        this.game = game;&#10;    }&#10;&#10;    @Override&#10;    public void show() {&#10;        batch = new SpriteBatch();&#10;        barajaTexture = new Texture(Gdx.files.internal(&quot;sprites/baraja.png&quot;));&#10;        cartas = new TextureRegion[4][12];&#10;        viewport = new FitViewport(VIRTUAL_WIDTH, VIRTUAL_HEIGHT);&#10;        recortarCartas();&#10;        seleccionarCartasAleatorias();&#10;    }&#10;&#10;    private void recortarCartas() {&#10;        int cartaW = barajaTexture.getWidth() / 12;&#10;        int cartaH = barajaTexture.getHeight() / 4;&#10;        for (int fila = 0; fila &lt; 4; fila++) {&#10;            for (int col = 0; col &lt; 12; col++) {&#10;                cartas[fila][col] = new TextureRegion(barajaTexture, col * cartaW, fila * cartaH, cartaW, cartaH);&#10;            }&#10;        }&#10;    }&#10;&#10;    private void seleccionarCartasAleatorias() {&#10;        cartasMostradas = new int[3][2];&#10;        for (int i = 0; i &lt; 3; i++) {&#10;            int fila = MathUtils.random(0, 3);&#10;            int col = MathUtils.random(0, 11);&#10;            cartasMostradas[i][0] = fila;&#10;            cartasMostradas[i][1] = col;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void render(float delta) {&#10;        // Aplicar viewport antes de dibujar&#10;        viewport.apply();&#10;        batch.setProjectionMatrix(viewport.getCamera().combined);&#10;&#10;        Gdx.gl.glClearColor(0, 0.5f, 0, 1);&#10;        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);&#10;&#10;        batch.begin();&#10;        int cartaW = 100, cartaH = 150;&#10;        int espacio = 40;&#10;        int totalW = 3 * cartaW + 2 * espacio;&#10;        int startX = (int)((VIRTUAL_WIDTH - totalW) / 2);&#10;        int y = (int)(VIRTUAL_HEIGHT / 2 - cartaH / 2);&#10;&#10;        for (int i = 0; i &lt; 3; i++) {&#10;            int fila = cartasMostradas[i][0];&#10;            int col = cartasMostradas[i][1];&#10;            TextureRegion carta = cartas[fila][col];&#10;            batch.draw(carta, startX + i * (cartaW + espacio), y, cartaW, cartaH);&#10;        }&#10;        batch.end();&#10;    }&#10;&#10;    @Override&#10;    public void resize(int width, int height) {&#10;        if (viewport != null) {&#10;            viewport.update(width, height, true);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void pause() {&#10;    }&#10;&#10;    @Override&#10;    public void resume() {&#10;    }&#10;&#10;    @Override&#10;    public void hide() {&#10;    }&#10;&#10;    @Override&#10;    public void dispose() {&#10;        batch.dispose();&#10;        barajaTexture.dispose();&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.Envit.Juego.pantallas;&#10;&#10;import com.Envit.Juego.Principal;&#10;import com.badlogic.gdx.Gdx;&#10;import com.badlogic.gdx.Screen;&#10;import com.badlogic.gdx.Input;&#10;import com.badlogic.gdx.graphics.Color;&#10;import com.badlogic.gdx.graphics.GL20;&#10;import com.badlogic.gdx.graphics.Texture;&#10;import com.badlogic.gdx.graphics.g2d.SpriteBatch;&#10;import com.badlogic.gdx.graphics.g2d.TextureRegion;&#10;import com.badlogic.gdx.math.MathUtils;&#10;import com.badlogic.gdx.utils.viewport.FitViewport;&#10;import com.badlogic.gdx.utils.viewport.Viewport;&#10;&#10;public class PantallaPartida implements Screen {&#10;    private final Principal game;&#10;    private SpriteBatch batch;&#10;    private Texture barajaTexture;&#10;    private TextureRegion[][] cartas; // [fila][columna]&#10;    private int[][] cartasMostradas; // [3][2] -&gt; fila, columna&#10;&#10;    // Viewport para mantener relación de aspecto&#10;    private static final float VIRTUAL_WIDTH = 1000;&#10;    private static final float VIRTUAL_HEIGHT = 625;&#10;    private Viewport viewport;&#10;&#10;    // Gestión de estados&#10;    private enum EstadoJuego { JUGANDO, PAUSADO, FINALIZADO }&#10;    private EstadoJuego estado = EstadoJuego.JUGANDO;&#10;&#10;    public PantallaPartida(Principal game) {&#10;        this.game = game;&#10;    }&#10;&#10;    @Override&#10;    public void show() {&#10;        batch = new SpriteBatch();&#10;        barajaTexture = new Texture(Gdx.files.internal(&quot;sprites/baraja.png&quot;));&#10;        cartas = new TextureRegion[4][12];&#10;        viewport = new FitViewport(VIRTUAL_WIDTH, VIRTUAL_HEIGHT);&#10;        recortarCartas();&#10;        seleccionarCartasAleatorias();&#10;    }&#10;&#10;    private void recortarCartas() {&#10;        int cartaW = barajaTexture.getWidth() / 12;&#10;        int cartaH = barajaTexture.getHeight() / 4;&#10;        for (int fila = 0; fila &lt; 4; fila++) {&#10;            for (int col = 0; col &lt; 12; col++) {&#10;                cartas[fila][col] = new TextureRegion(barajaTexture, col * cartaW, fila * cartaH, cartaW, cartaH);&#10;            }&#10;        }&#10;    }&#10;&#10;    private void seleccionarCartasAleatorias() {&#10;        cartasMostradas = new int[3][2];&#10;        for (int i = 0; i &lt; 3; i++) {&#10;            int fila = MathUtils.random(0, 3);&#10;            int col = MathUtils.random(0, 11);&#10;            cartasMostradas[i][0] = fila;&#10;            cartasMostradas[i][1] = col;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void render(float delta) {&#10;        // Aplicar viewport antes de dibujar&#10;        viewport.apply();&#10;        batch.setProjectionMatrix(viewport.getCamera().combined);&#10;&#10;        Gdx.gl.glClearColor(0, 0.5f, 0, 1);&#10;        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);&#10;&#10;        manejarInput();&#10;&#10;        batch.begin();&#10;        int cartaW = 100, cartaH = 150;&#10;        int espacio = 40;&#10;        int totalW = 3 * cartaW + 2 * espacio;&#10;        int startX = (int)((VIRTUAL_WIDTH - totalW) / 2);&#10;        int y = (int)(VIRTUAL_HEIGHT / 2 - cartaH / 2);&#10;&#10;        // Dibuja cartas solo si no está finalizado&#10;        if (estado != EstadoJuego.FINALIZADO) {&#10;            for (int i = 0; i &lt; 3; i++) {&#10;                int fila = cartasMostradas[i][0];&#10;                int col = cartasMostradas[i][1];&#10;                TextureRegion carta = cartas[fila][col];&#10;                batch.draw(carta, startX + i * (cartaW + espacio), y, cartaW, cartaH);&#10;            }&#10;        }&#10;&#10;        // Overlay de pausa&#10;        if (estado == EstadoJuego.PAUSADO) {&#10;            // Fondo semitransparente&#10;            batch.setColor(0, 0, 0, 0.5f);&#10;            batch.draw(getWhitePixel(), 0, 0, VIRTUAL_WIDTH, VIRTUAL_HEIGHT);&#10;            batch.setColor(Color.WHITE);&#10;            // Texto de pausa&#10;            // Puedes usar BitmapFont si tienes una fuente cargada globalmente&#10;            // Aquí solo se muestra el concepto&#10;            // font.draw(batch, &quot;PAUSA\n[ESC] Reanudar\n[M] Menú&quot;, VIRTUAL_WIDTH/2-100, VIRTUAL_HEIGHT/2+40);&#10;        }&#10;        batch.end();&#10;    }&#10;&#10;    private void manejarInput() {&#10;        if (Gdx.input.isKeyJustPressed(Input.Keys.ESCAPE)) {&#10;            if (estado == EstadoJuego.JUGANDO) {&#10;                estado = EstadoJuego.PAUSADO;&#10;            } else if (estado == EstadoJuego.PAUSADO) {&#10;                estado = EstadoJuego.JUGANDO;&#10;            }&#10;        }&#10;        if (estado == EstadoJuego.PAUSADO &amp;&amp; Gdx.input.isKeyJustPressed(Input.Keys.M)) {&#10;            game.setScreen(new PantallaMenu(game));&#10;        }&#10;    }&#10;&#10;    // Textura 1x1 blanca para overlays&#10;    private Texture whitePixel;&#10;    private Texture getWhitePixel() {&#10;        if (whitePixel == null) {&#10;            com.badlogic.gdx.graphics.Pixmap pixmap = new com.badlogic.gdx.graphics.Pixmap(1,1, com.badlogic.gdx.graphics.Pixmap.Format.RGBA8888);&#10;            pixmap.setColor(Color.WHITE);&#10;            pixmap.fill();&#10;            whitePixel = new Texture(pixmap);&#10;            pixmap.dispose();&#10;        }&#10;        return whitePixel;&#10;    }&#10;&#10;    @Override&#10;    public void resize(int width, int height) {&#10;        if (viewport != null) {&#10;            viewport.update(width, height, true);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void pause() {}&#10;&#10;    @Override&#10;    public void resume() {}&#10;&#10;    @Override&#10;    public void hide() {}&#10;&#10;    @Override&#10;    public void dispose() {&#10;        batch.dispose();&#10;        barajaTexture.dispose();&#10;        if (whitePixel != null) whitePixel.dispose();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>